# This file is part of OLMS (Open Library of Mathematical Sequences).
# Copyright Peter Luschny. License is MIT.
# This file includes portions from Combinatorics.jl and Primes.jl
# in modified form. License is MIT, http://julialang.org/license

# Version of: UTC 2018-01-31 13:17:47
# bfbdd5f0-0680-11e8-37a6-39b9dbb36ac0

# Do not edit this file, it is generated from the modules and will be overwritten!
# Edit the modules in the modules directory and build this file with MathIntSeqBuild.jl!

# Reporting a bug please give date, uuid and line number in this file, not of modules.

module MathIntSeq
using Memoize, HTTP, Nemo, OffsetArrays, IterTools
export 
Accumulate,
André,
Apéry,
AssertSeqArray,
AssertTriangular,
BellNumber,
BellNumberList,
BellTrans,
BellTriangle,
Bernoulli,
BernoulliInt,
BernoulliIntList,
BernoulliList,
BinaryIntegerLength,
Binomial,
CatalanNumber,
CentralBinomial,
ClausenNumber,
ClausenNumberList,
Count,
CountList,
DedekindEtaPowers,
DeléhamΔ,
Derangement,
Divides,
Divisors,
Enumerator,
F!,
Factorial,
Factors,
FallingFactorial,
FibonacciGeneralized,
FibonacciGeneralizedList,
FibonacciNumber,
FibonacciNumberList,
FillArray,
FindInInterval,
FindMaxima,
FindMaximaUpTo,
FindUpTo,
First,
GammaHyp,
GaußFactorial,
GaußLcm,
HasNoPrimitiveRoot,
HasPrimitiveRoot,
HilbertHotel,
IndexIn,
Indicators,
IndicatorsFind,
InvOrthoPoly,
IsAbundant,
IsComposite,
IsCyclic,
IsEven,
IsNonnegative,
IsOdd,
IsPerfectPower,
IsPositive,
IsPowerOfPrimes,
IsPrime,
IsPrimePower,
IsPrimeTo,
IsSeqArray,
IsSquare,
IsSquareFree,
IsStrongPrimeTo,
IsTriangular,
IsZumkeller,
IterateUpTo,
Iterator,
JacobiTheta3Powers,
JacobiTheta4Powers,
JacobsthalNumber,
JacobsthalNumberList,
KolakoskiList,
Lah,
LahTriangle,
Last,
List,
LouisaNumber,
MultiFactorial,
Next,
NextPrime,
Nth,
OrthoPoly,
Partition,
PartitionNumberList,
Pascal,
PolygonalNumber,
Previous,
PreviousPrime,
PrimeDivisors,
PrimeList,
PrimePiList,
Primes,
Product,
PyramidalNumber,
Radical,
RamanujanTau,
RamanujanTauList,
Recurrence2,
RisingFactorial,
Row,
RowReverse,
RowSums,
SelfConvRec,
SeqArray,
SeqName,
SeqNum,
SeqPrint,
SeqRange,
SeqShow,
SeqSize,
SeqTriangle,
Show,
ShowAsMatrix,
Start,
StirlingCycle,
StirlingCycleTriangle,
StirlingLah,
StirlingLahTriangle,
StirlingSet,
StirlingSetTriangle,
Subfactorial,
Swing,
TriangularNumber,
ZumkellerNumberList,
combinations,
mods,
oeis_isinstalled,
oeis_local,
oeis_notinstalled,
oeis_path,
oeis_remote,
oeis_search,
oeis_trimdata,
oeis_writebfile,
primesmask,
Δto□,
Ω,
ι,
ιι,
σ,
τ,
ω,
ϕ,
↑,
↓,
∏,
⊥,
⍊,
□toΔ,
C000002,
L000002,
A000005,
A000010,
L000041,
A000045,
L000045,
L000085,
A000108,
A000110,
L000110,
A000111,
C000111,
L000118,
L000122,
L000132,
L000141,
A000142,
L000143,
L000144,
L000145,
A000165,
A000166,
A000203,
A000217,
L000246,
A000255,
A000262,
A000290,
A000292,
A000326,
A000330,
T000369,
A000384,
A000407,
A000566,
A000567,
L000594,
L000698,
L000712,
L000716,
L000720,
L000727,
L000728,
L000729,
L000730,
L000731,
L000735,
L000739,
L000961,
A000984,
L001040,
A001045,
L001045,
L001046,
A001106,
A001107,
A001147,
A001221,
A001222,
L001464,
A001477,
T001497,
L001710,
A001783,
L001783,
A001790,
A001803,
A001813,
A001855,
L001934,
B002093,
C002093,
L002093,
L002107,
A002110,
B002182,
L002182,
B002183,
L002183,
A002411,
A002412,
A002413,
A002414,
A002445,
L002445,
L002448,
A002457,
L002467,
B002476,
L002808,
L003277,
A003314,
L003319,
L003723,
L004018,
L004402,
L004403,
L004404,
L004405,
L004406,
L004407,
L004408,
L004409,
L004410,
L004411,
L004412,
L004413,
L004414,
L004415,
L004416,
L004417,
L004418,
L004419,
L004420,
L004421,
L004422,
L004423,
L004424,
L004425,
T004747,
B005101,
C005101,
L005101,
L005117,
L005411,
L005412,
L005425,
A005430,
L005442,
A005564,
L005758,
L005773,
L005875,
B006005,
L006005,
L006012,
B006093,
L006093,
A006130,
L006130,
A006131,
L006131,
L006229,
L006318,
L006922,
A007060,
T007318,
B007522,
A007559,
A007584,
A007585,
A007696,
A007917,
L008451,
L008452,
L008453,
A008544,
A008545,
A008683,
B008784,
L010815,
L010816,
L010817,
L010819,
L010820,
L010821,
L010822,
L010823,
L010824,
L010825,
L010826,
L010827,
L010828,
L010829,
L010830,
L010831,
L010832,
L010833,
L010834,
L010835,
L010836,
L010837,
L010838,
L010839,
L010840,
L010841,
T011117,
L013928,
A014107,
L015128,
A015440,
L015440,
A015441,
L015441,
A015442,
L015442,
A015443,
L015443,
A015445,
L015445,
L023003,
L023004,
L023005,
L023006,
L023007,
L023008,
L023009,
L023010,
L023011,
L023012,
L023013,
L023014,
L023015,
L023016,
L023017,
L023018,
L023019,
L023020,
L023021,
L024167,
L025528,
T026300,
A027641,
A027642,
B031363,
A032031,
A033156,
A033815,
B033948,
B033949,
B034017,
A034386,
A034444,
B034885,
L034885,
L035016,
B035251,
L036246,
T037027,
T038207,
A038610,
L038610,
B038872,
B038873,
T039683,
B042965,
A047053,
L047891,
T048993,
T049218,
T049310,
A049606,
T051141,
T051142,
T053117,
T053120,
T053121,
L053602,
A054248,
A055634,
T055883,
A056040,
L056953,
B057126,
B057127,
A057977,
L058279,
A058373,
L058797,
T059419,
T060693,
A061142,
A061168,
L062980,
T064189,
L065515,
A065619,
L065619,
L065855,
T066325,
A066570,
A067998,
B068228,
L069637,
A080397,
A080577,
A080956,
A081125,
L082298,
L082301,
L082302,
L082556,
L082557,
L082558,
L082559,
L083207,
A083652,
A083856,
B084916,
T084938,
T088969,
B089270,
T090238,
T090981,
T094665,
A095794,
L096727,
A097383,
A099022,
T099174,
A103131,
L103131,
T104556,
T104562,
L104794,
L105523,
A105927,
T106566,
L107716,
L108624,
T111062,
L111529,
L111530,
L111531,
L111532,
L111533,
T111593,
T119274,
A123753,
A124320,
A124441,
L124441,
A124442,
L124442,
A128247,
L128247,
T132062,
T132393,
T137286,
T137338,
T137452,
T137513,
B141158,
L146559,
A151800,
T159834,
A160377,
L160377,
L163085,
A163590,
A163641,
L166474,
L167872,
A178963,
A178964,
A180000,
A181830,
A181936,
T184962,
A195441,
T202327,
T203412,
L213384,
T216916,
A216919,
T217537,
L217924,
T225478,
B242660,
B243168,
B243655,
B244291,
B244779,
B244780,
B244819,
L246547,
L246655,
A250283,
A251568,
A254749,
A257993,
T264428,
T265606,
A265609,
T268434,
T269944,
T269945,
T269946,
T269947,
T269948,
T271703,
L276285,
L276286,
L276287,
A281586,
A281588,
A281594,
L286032,
A295513
# +++ Abundant.jl +++
doc"""
Is ``n`` an abundant number, i.e. is ``σ(n) > 2n `` ?
"""
IsAbundant(n) = σ(n) - n > n
doc"""
Generate the abundant numbers which are the numbers such that ``σ(n) > 2n``.
"""
C005101() = Channel(csize=4) do c
    n = 0
    while true
        IsAbundant(n) && put!(c, ZZ(n))
        n += 1
    end
end
doc"""
Generate the highly abundant numbers which are the numbers where record values
of ``σ(n)`` occur.
"""
C002093() = Channel(csize=2) do c
    for n in 1:4 put!(c, ZZ(n)) end
    n = high = ZZ(4)
    while true
        n += 2
        s = σ(n)
        if s > high
            high = s
            put!(c, n)
        end
    end
end
doc"""
Return a list of length len of highly abundant numbers.
julia> L002093(8)
[0, 1, 2, 3, 4, 6, 8, 10, 12]
"""
L002093(len) = SeqArray(len, C002093())
doc"""
Return a list of length len of abundant numbers.
julia> L005101(9)
[12, 18, 20, 24, 30, 36, 40, 42, 48]
"""
L005101(len) = SeqArray(len, IsAbundant)
doc"""
Return a list of abundant numbers which do not exceed the given bound.
julia> B005101(50)
[12, 18, 20, 24, 30, 36, 40, 42, 48]
"""
B005101(bound) = FindUpTo(bound, IsAbundant)
# +++ Andre.jl +++
doc"""
Return the generalized André numbers which are the ``m``-alternating
permutations of length ``n``. Cf. A181937.
julia> [André(2, n) for n in 0:10]
[1, 1, -1, -2, 5, 16, -61, -272, 1385, 7936, -50521]
"""
André(m, n) = A(m, n)
@memoize function A(m, n)
    n ≤ 0 && return ZZ(1)
    r = range(0, m, div(n + m - 1, m))
    S = sum(binom(n, k) * A(m, k) for k in r)
    n % m == 0 ? -S : S
end
doc"""
Return the generalized André numbers which are the ``m``-alternating permutations
of length ``n``.
julia> [A181937(3, n) for n in 0:10]
[1, 1, 1, 1, 3, 9, 19, 99, 477, 1513, 11259]
"""
A181937(m::Int, n::Int) = abs(A(m, n))
doc"""
Return the up-down numbers (2-alternating permutations).
julia> A000111(10)
50521
"""
A000111(n::Int) = abs(André(2, n))
doc"""
Return the number of 3-alternating permutations.
julia> [A178963(n) for n in 0:10]
[1, 1, 1, 1, 3, 9, 19, 99, 477, 1513, 11259]
"""
A178963(n::Int) = abs(André(3, n))
doc"""
Return the number of 4-alternating permutations.
julia> [A178964(n) for n in 0:10]
[1, 1, 1, 1, 1, 4, 14, 34, 69, 496, 2896]
"""
A178964(n::Int) = abs(André(4, n))
doc"""
Return the number of 5-alternating permutations.
julia> [A181936(n) for n in 0:10]
[1, 1, 1, 1, 1, 1, 5, 20, 55, 125, 251]
"""
A181936(n::Int) = abs(André(5, n))
doc"""
Return the number of 6-alternating permutations.
julia> [A250283(n) for n in 0:10]
[1, 1, 1, 1, 1, 1, 1, 6, 27, 83, 209]
"""
A250283(n::Int) = abs(André(6, n))
doc"""
Generate the André numbers (a.k.a. Euler-up-down numbers A000111).
Don't confuse with the Euler numbers A122045.
"""
C000111() = Channel(csize=2) do c
    D = Dict{Int,fmpz}(0 => 1, -1 => 0)
    i = k = 0
    s = 1
    while true
        A = 0; D[k + s] = 0; s = -s
        for j in 0:i
            A += D[k]; D[k] = A; k += s
        end
        put!(c, A)
        i += 1
    end
end
# +++ BellNumbers.jl +++
doc"""
Return a list of the first m Bell numbers (a.k.a. exponential numbers).
"""
function BellNumberList(m::Int)
    m == 0 && return fmpz[]
    R = SeqArray(m)
    R[0] = 1; m == 1 && return R
    R[1] = 1; m == 2 && return R
    A = SeqArray(m)
    A[0] = fmpz(1)
    for n in 1:m - 2
        A[n] = A[0]
        for k in n:-1:1
            A[k - 1] += A[k]
        end
        R[n + 1] = A[0]
    end
    R
end
doc"""
Return the n-th Bell number. Bell numbers count the ways to partition a set of
``n`` labeled elements.
julia> BellNumber(10)
115975
"""
BellNumber(n::Int) = Nemo.bell(n)
doc"""
Return the n-th Bell number ``B_n``.
julia> A000110(11)
678570
"""
A000110(n::Int) = Nemo.bell(n)
doc"""
Return a list of Bell numbers of length len.
julia> L000110(10)
[1, 1, 2, 5, 15, 52, 203, 877, 4140, 21147]
"""
L000110(len::Int) = BellNumberList(len)
doc"""
The Bell transform transforms an integer sequence into an integer triangle;
also known as incomplete Bell polynomials.
Let ``X`` be an integer sequence, then
``$B_{n,k}(X) = \sum_{m=1}^{n-k+1} \binom{n-1}{m-1} X[m] B_{n-m,k-1}(X)$`` where
``B_{0,0} = 1, B_{n,0} = 0`` for ``n≥1, B_{0,k} = 0`` for ``k≥1``.
"""
BellTrans(n::Int, k::Int, X) = Belltrans(n, k, X)
@memoize function Belltrans(n::Int, k::Int, X::Array)
    a = fmpz(1); s = fmpz(0)
    if (n == 0) && (k == 0) return a end
    if (n == 0) || (k == 0) return s end
    for m in 1:n-k+1
        s += a * Belltrans(n - m, k - 1, X) * X[m]
        a = div(a * (n - m), m)
    end
    s
end
@memoize function Belltrans(n::Int, k::Int, X::Function)
    a = fmpz(1); s = fmpz(0)
    if (n == 0) && (k == 0) return a end
    if (n == 0) || (k == 0) return s end
    for m in 1:n-k+1
        s += a * Belltrans(n - m, k - 1, X) * X(m - 1)
        a = div(a * (n - m), m)
    end
    s
end
doc"""
The Bell triangle gathers the results of the Bell transform applied to the
initial segments of the input sequence.
Famously the sequence (1,1,1,...) is mapped to the triangle of the Stirling
set numbers.
julia> Show(BellTriangle(5, k -> 1))
1
0 1
0 1 1
0 1 3 1
0 1 7 6 1
"""
function BellTriangle(n::Int, seq)
    M = SeqTriangle(n)
    i = 0
    for j in 0:n - 1, k in 0:j
        M[i] = BellTrans(j, k, seq)
        i += 1
    end
    M
end
doc"""
Return the coefficients of the first ``n`` Abel polynomials.
julia> Show(T137452(5))
1
0 1
0 -2 1
0 9 -6 1
0 -64 48 -12 1
"""
T137452(n::Int) = BellTriangle(n, k -> (-k - 1)^k)
doc"""
Return the Bell transform of the Bell numbers.
julia> Show(T264428(5))
1
0 1
0 1 1
0 2 3 1
0 5 11 6 1
"""
T264428(n::Int) = BellTriangle(n, BellNumber)
doc"""
Return the triangle of the coefficients of the Mittag-Leffler polynomials.
julia> Show(T137513(5))
1
0 2
0 0 4
0 4 0 8
0 0 32 0 16
"""
T137513(n::Int) = BellTriangle(n, k -> IsOdd(k) ? 0 : 2fac(k))
doc"""
Return the matrix inverse of coefficients of Bessel polynomials; essentially the
same as coefficients of modified Hermite polynomials T096713.
julia> Show(T104556(5))
1
0 1
0 -1 1
0 0 -3 1
0 0 3 -6 1
"""
T104556(n::Int) = BellTriangle(n, k -> k < 2 ? (-1)^k : 0)
doc"""
Return a triangle of coefficients of Bessel polynomials (better use A132062).
"""
T001497(n::Int) = BellTriangle(n, MultiFactorial(2, 1))
doc"""
Return the triangle of coefficients of Bessel polynomials, also the Sheffer
triangle ``(1, 1 - √(1 - 2x))`` (Cf. A001497).
julia> Show(T132062(5))
1
0 1
0 1 1
0 3 3 1
0 15 15 6 1
"""
T132062(n::Int) = BellTriangle(n, MultiFactorial(2, 1))
doc"""
Return the signed double Pochhammer triangle: expansion of ``x(x-2)(x-4)..(x-2n+2)``.
julia> Show(T039683(5))
1
0 1
0 2 1
0 8 6 1
0 48 44 12 1
"""
T039683(n::Int) = BellTriangle(n, MultiFactorial(2, 2))
doc"""
Return the Bell transform of the MultiFactorial numbers of type (3,1).
julia> Show(T203412(5))
1
0 1
0 1 1
0 4 3 1
0 28 19 6 1
"""
T203412(n::Int) = BellTriangle(n, MultiFactorial(3, 1))
doc"""
Return the Bell transform of the MultiFactorial numbers of type (3,2).
julia> Show(T004747(5))
1
0 1
0 2 1
0 10 6 1
0 80 52 12 1
"""
T004747(n::Int) = BellTriangle(n, MultiFactorial(3, 2))
doc"""
Return the triangle ``3^{n-m}S1(n, m)`` where S1 are the signed Stirling numbers
of first kind.
julia> Show(T051141(5))
1
0 1
0 3 1
0 18 9 1
0 162 99 18 1
"""
T051141(n::Int) = BellTriangle(n, MultiFactorial(3, 3))
doc"""
Return the Bell transform of the quartic factorial numbers.
julia> Show(T265606(5))
1
0 1
0 1 1
0 5 3 1
0 45 23 6 1
"""
T265606(n::Int) = BellTriangle(n, MultiFactorial(4, 1))
doc"""
Return the triangle of coefficients of numerators in Pade approximation to ``e^x``.
julia> Show(T119274(5))
1
0 1
0 2 1
0 12 6 1
0 120 60 12 1
"""
T119274(n::Int) = BellTriangle(n, MultiFactorial(4, 2))
doc"""
Return the Bell transform of the MultiFactorial numbers of type (4,3).
julia> Show(T000369(5))
1
0 1
0 3 1
0 21 9 1
0 231 111 18 1
"""
T000369(n::Int) = BellTriangle(n, MultiFactorial(4, 3))
doc"""
Return the Bell transform of the MultiFactorial numbers of type (4,4).
julia> Show(T051142(5))
1
0 1
0 4 1
0 32 12 1
0 384 176 24 1 
"""
T051142(n::Int) = BellTriangle(n, MultiFactorial(4, 4))
# +++ BernoulliNumbers.jl +++
doc"""
Return the generalized integer Bernoulli numbers ``b_{m}(n) = n`` André``_{m}(n-1)``.
julia> BernoulliInt(3, 10)
-15130
"""
BernoulliInt(m::Int, n::Int) = n == 0 ? ZZ(0) : n * André(m, n - 1)
doc"""
Return the number of down-up permutations w on ``[n+1]`` such that
``w_2 = 1``. (D. Callan)
julia> [A065619(n) for n in 0:9]
[0, 1, 2, -3, -8, 25, 96, -427, -2176, 12465]
"""
A065619(n::Int) = BernoulliInt(2, n)
doc"""
Return the generalized integer Bernoulli numbers ``b_{3}(n) = n``
André``_{3}(n-1)``.
julia> [A281586(n) for n in 0:9]
[0, 1, 2, 3, -4, -15, -54, 133, 792, 4293]
"""
A281586(n::Int) = BernoulliInt(3, n)
doc"""
Return the generalized integer Bernoulli numbers ``b_{4}(n) = n``
André``_{4}(n-1)``.
julia> [A281588(n) for n in 0:9]
[0, 1, 2, 3, 4, -5, -24, -98, -272, 621]
"""
A281588(n::Int) = BernoulliInt(4, n)
doc"""
Return a list of length len of the integer Bernoulli numbers ``b_{m}(n)``
"""
function BernoulliIntList(m::Int, len::Int)
    len ≤ 0 && return fmpz[]
    R = zeros(ZZ, len)
    len == 1 && return R
    R[2] = 1
    len == 2 && return R
    A = zeros(ZZ, len)
    A[1] = 1; A[2] = 1
    for n in 1:len - 2
        if n % m ≠ 0
            for i in n:-1:1 A[i] += A[i + 1] end
            C = A[1]
        else
            C = 0
            for i in 1:(n + 2) A[i], C = C, A[i]; C = A[i] - C end
        end
        R[n + 2] = C
    end
    R
end
doc"""
Computes a list of length len of the integer Bernoulli numbers ``b_{2}(n)``
julia> L065619(10)
[0, 1, 2, 3, 8, 25, 96, 427, 2176, 12465]
"""
function L065619(len::Int)
    len ≤ 0  && return fmpz[]
    R = SeqArray(len)
    len == 1 && return R
    len == 2 && (R[1] = 1; return R)
    A = Dict{Int,fmpz}(-1 => 1, 0 => 0)
    k = 0; e = 1
    for i in 0:len - 1
        Am = 0; A[k + e] = 0; e = -e
        for j in 0:i
            Am += A[k]; A[k] = Am; k += e
        end
        j = e < 0 ? div(-i, 2) : div(i, 2)
        R[i] = A[j]
    end
    R
end
doc"""
Return the rational Bernoulli number ``B_n``. Cf. A027641/A027642.
julia> Bernoulli(12)
-691/2730
"""
function Bernoulli(n::Int)
    IsOdd(n) && (n == 1 ? (return fmpq(1, 2)) : (return fmpq(0, 1)))
    n == 0 && return fmpq(1)
    denom = ^(ZZ(4), n) - ^(ZZ(2), n)
    fmpq(BernoulliInt(2, n), denom)
end
doc"""
Return a list of the first len Bernoulli numbers ``B_n``. Cf. A027641/A027642.
julia> BernoulliList(10)
[1, 1//2, 1//6, 0, -1//30, 0, 1//42, 0, -1//30, 0]
"""
function BernoulliList(len::Int)
    if len ≤ 0 return fmpq[] end
    R = Array{fmpq}(len)
    R[1] = fmpq(1, 1); len == 1 && return R
    R[2] = fmpq(1, 2); len == 2 && return R
    A = Dict{Int,fmpz}(0 => 1, -2 => 0, -1 => 1, 1 => 0)
    a = fmpz(12); b = fmpz(240)
    k = e = 1
    for i in 2:len - 1
        Am = 0; A[k + e] = 0; e = -e
        for j in 0:i
            Am += A[k]; A[k] = Am; k += e
        end
        if e > 0
            R[i + 1] = fmpq(0, 1)
        else
            d = i >> 1
            R[i + 1] = IsEven(d) ? fmpq(-A[-d], a) : fmpq(A[-d], a)
            a, b = b, b << 4 + b << 2 - a << 6
        end
    end
    R
end
doc"""
Return the numerator of the Bernoulli number ``B_n``.
julia> [A027641(n) for n in 0:10]
[1, -1, 1, 0, -1, 0, 1, 0, -1, 0, 5]
"""
function A027641(n::Int)
    IsOdd(n) && (n == 1 ? (return ZZ(-1)) : return ZZ(0))
    n == 0 && return ZZ(1)
    denom = ^(ZZ(4), n) - ^(ZZ(2), n)
    Nemo.num(BernoulliInt(2, n) // denom)
end
doc"""
Return denominator(Bernoulli ``_{n+1}(x) - `` Bernoulli ``_{n+1})``.
julia> [A195441(n) for n in 0:9]
[1, 1, 2, 1, 6, 2, 6, 3, 10, 2]
"""
function A195441(n::Int)
    n < 4 && return ZZ([1, 1, 2, 1][n + 1])
    P = Primes(2, div(n + 2, 2 + n % 2))
    ∏([p for p in P if p ≤ sum(digits(n + 1, Int(p)))])
end
# +++ BinaryInteger.jl +++
doc"""
Return the length of the binary extension of an integer ``n``, which is defined
as ``0`` if ``n = 0`` and for ``n > 0`` as ``⌊ log2(n) ⌋ + 1``.
"""
BinaryIntegerLength(n) = n == 0 ? 0 : Int(floor(log2(n))) + 1
doc"""
Alias for the function BinaryIntegerLength.
"""
bil(n) = BinaryIntegerLength(n)
doc"""
Return ``n ``BinaryIntegerLength``(n) - 2^``BinaryIntegerLength``(n)``.
"""
A295513(n) = n*bil(n) - 2^bil(n)
doc"""
Maximal number of comparisons for sorting ``n`` elements by binary insertion.
"""
A001855(n) = A295513(n) + 1
doc"""
Return the sum of lengths of binary expansions of ``0`` through ``n``.
"""
A083652(n) = A295513(n+1) + 2
doc"""
Recurrence ``a(n) = a(n-1) + ⌊ a(n-1)/(n-1) ⌋ + 2`` for ``m ≥ 2`` and ``a(1) = 1``.
"""
A033156(n) = A295513(n) + 2n
doc"""
Binary entropy function: ``a(n) = n + min { a(k) + a(n-k) : 1 ≤ k ≤ n-1 }`` for
``n > 1,`` and ``a(1) = 0``.
"""
A003314(n) = A295513(n) + n
doc"""
Binary entropy: ``a(n) = n + min { a(k) + a(n-k) : 1 ≤ k ≤ n-1 }.``
"""
A054248(n) = A295513(n) + n + rem(n, 2)
doc"""
Minimum total number of comparisons to find each of the values ``1`` through ``n``
"""
A097383(n) = A295513(n+1) - div(n-1, 2)
doc"""
Partial sums of the sequence ``⌊ log_2(n) ⌋``.
"""
A061168(n) = A295513(n+1) - n + 1
doc"""
Partial sums of the sequence of length of the binary expansion of ``2n+1``.
"""
A123753(n) = A295513(n+1) + n + 2
# +++ BinaryQF.jl +++
doc"""
Return integers that are represented by the binary quadratic form
``a x^2 + b xy + c y^2`` over Z. Parameter 'subset' is in {"positive", "primitively",
"prime"}. Use it only as a 'private' function.
"""
function binaryQF(a::Int, b::Int, c::Int, bound = 100::Int, subset = "positive", verbose = false)
    α, β, γ = a, b, c
    discriminant() = fmpz(β^2 - 4 * α * γ)
    isreduced() = (-α < β ≤ α < γ) || (fmpz(0) ≤ β ≤ α == γ)
    function roots(a::Int, b::Int, c::Int, n::Int, y::Int)
    throw(ErrorException("not yet implemented"))
end
    function sqr_disc(M, primitively = false)
    d = discriminant()
    d == 0 && throw(ValueError("discriminant must not be zero"))
    a, b, c = α, β, γ
    (a == 0 && c == 0) && return [b * n for n in 1:div(M, abs(b))]
    D = isqrt(d)
    if a == 0
        a, c = c, 0
    end
    k = 2 * D; m = 4 * a * D
    u = b + D; v = b - D
    S = fmpz[]
    for n in 1:M
        h = fmpz(4 * a * n)  # a <> 0 and n <> 0
        for t in Divisors(h) # returns fmpz
            g = fmpz(div(h, t))
            if rem(g - t, k) == 0 && rem(g * u - t * v, m) == 0
                if primitively
                    y = div(g - t, k)
                    R = roots(a, b, c, n, y)
                    if IsPrimeTo(R[1], y)
                        push!(S, n)
                        break
                    end
                else
                    push!(S, n)
                    break
                end
            end
        end
    end
    sort([s for s in Set(S)])
end
    function imag_prime(M)
    throw(ErrorException("not yet implemented"))
end
    function imag_primitively(M)
    a, b, c = α, β, γ
    d = c - div(b * b, 4 * a)
    A = []
    for y in 0:isqrt(div(M, d))
        r = y * b / (2 * a)
        s = sqrt((M - d * y * y) / a)
        for x in Int(round(ceil(-s - r))):Int(round(floor(s - r)))
            IsPrimeTo(x, y) && push!(A, a * x^2 + b * x * y + c * y^2)
        end
    end
    sort([s for s in Set(A)])
end
    function imag_positive(M)
    throw(ErrorException("not yet implemented"))
end
    function primitive_reps(a, h, b, M, S)
    if a ≤ M
        push!(S, a)
        if b ≤ M
            push!(S, b)
            if a ≤ (M - b) && h ≤ (M - a - b)
                a ≤ (M - a - h) && primitive_reps(a, h + 2 * a, a + b + h, M, S)
                b ≤ (M - b - h) && primitive_reps(a + b + h, h + 2 * b, b, M, S)
            end
        end
    end
end
    function positive_primitives(bound, primitively)
    a, b, c = α, β, γ
    S = fmpz[]
    while true
        new_val = a + b + c
        if new_val > 0
            primitive_reps(a, b + 2 * a, new_val, bound, S)
            b += 2 * c
            a = new_val
        else
            if new_val < 0
                b += 2 * a
                c = new_val
            end
        end
        if a == α && b == β && c == γ break end
    end
    if ! primitively
        X = fmpz[]
        for p in S
            q = t = 1
            while q ≤ bound
                push!(X, q)
                q = t * t * p
                t += 1
            end
        end
        S = X
    end
    sort([s for s in Set(S)])
end
    function reduce_real()
    d = discriminant()
    IsSquare(d) && throw(ValueError("form must not have square discriminant"))
    droot = isqrt(d)
    a, b, c = α, β, γ
    while a ≤ 0 || c ≥ 0 || b ≤ abs(a + c)
        cAbs = c
        if cAbs < 0  cAbs *= -1 end
        delta = div(b + droot, 2 * cAbs)
        if c < 0  delta *= -1 end
        aa = c
        bb = 2 * c * delta - b
        cc = c * delta * delta - b * delta + a
        a, b, c = aa, bb, cc
    end
    return [a, b, c]
end
    function reduce_imag()
    a, b, c = α, β, γ
    if a < 0
        a, b, c = -a, -b, -c
    end
    d = discriminant()
    while true
        A = (a == c && b < 0) || (c < a)
        B = (-a == b && a < c) || (a < abs(b))
        !(A || B) && break
        if A
            a, b, c = c, -b, a
        end
        if B
            b -= 2 * a * div(b, 2 * a)
            if abs(b) > a  b -= 2 * a end
            c = div(b * b - d, 4 * a)
        end
    end
    return [a, b, c]
end
    function reduced_form()
    isreduced() && return [α, β, γ]
    if discriminant() ≥ 0
        return reduce_real()
    else
        return reduce_imag()
    end
end
    prime = false || subset == "prime"
    primitively = false || subset == "primitively"
    d = discriminant()
    d == 0 && throw(ValueError("discriminant must not be 0"))
    a, b, c = α, β, γ
    if verbose
        println("Original form [", a, ", ", b, ", ", c, "] with discriminant ", d)
    end
    if IsSquare(d)
        verbose && println("Square discriminant!")
        if prime primitively = false end # for efficiency
        pp = sqr_disc(bound, primitively)
        if prime pp = [m for m in pp if IsPrime(m)] end
    else
        α, β, γ = reduced_form()
        verbose && println("Reduced form  [", α, ", ", β, ", ", γ, "]")
        if d < 0
            if prime
                pp = imag_prime(bound)
            else
                if primitively
                    pp = imag_primitively(bound)
                else
                    pp = imag_positive(bound)
                end
            end
        else # d > 0 and not square
            if prime
                primitively = true
            end # for efficiency
            pp = positive_primitives(bound, primitively)
            if prime pp = [m for m in pp if IsPrime(m)] end
        end
    end
    if verbose
        msg0 = prime ? " primes " : " positive integers "
        msg1 = primitively ? "primitively " : ""
        msg2 = "represented up to "
        println("There are ", length(pp), msg0, msg1, msg2, bound)
    end
    SeqArray(pp)
end # binary_QF
doc"""
Return positive numbers of the form ``n = x^2-3y^2`` of discriminant 12.
"""
B084916(bound::Int) = binaryQF(1, 0, -3, bound)
doc"""
Return positive numbers that are primitively represented by the indefinite quadratic
form ``x^2 - 3y^2`` of discriminant 12.
"""
B243655(bound::Int) = binaryQF(1, 0, -3, bound, "primitively")
doc"""
Return primes congruent to 1 (mod 12).
"""
B068228(bound::Int) = binaryQF(1, 0, -3, bound, "prime")
doc"""
Return positive numbers of the form ``x^2+xy-2y^2``.
"""
B242660(bound::Int) = binaryQF(1, 1, -2, bound)
doc"""
Return positive numbers primitively represented by the binary quadratic form (1,1,-2).
"""
B244713(bound::Int) = binaryQF(1, 1, -2, bound, "primitively")
doc"""
Return primes of the form ``6m + 1``.
"""
B002476(bound::Int) = binaryQF(1, 1, -2, bound, "prime")
doc"""
Return positive numbers of the form ``x^2 - 2y^2`` with integers ``x, y``
(discriminant is 8).
"""
B035251(bound::Int) = binaryQF(1, 0, -2, bound)
doc"""
Return mumbers n such that 2 is a square mod n.
"""
B057126(bound::Int) = binaryQF(1, 0, -2, bound, "primitively")
doc"""
Return primes p such that 2 is a square mod p; or, primes congruent to
``{1, 2, 7}`` mod ``8``.
"""
B038873(bound::Int) = binaryQF(1, 0, -2, bound, "prime")
doc"""
Return positive numbers of the form ``x^2+xy-y^2``; or, of the form ``5x^2-y^2``.
"""
B031363(bound::Int) = binaryQF(1, 1, -1, bound) # "positive"
doc"""
Return positive numbers represented by the integer binary quadratic form ``x^2+xy-y^2``
with ``x`` and ``y`` relatively prime.
"""
B089270(bound::Int) = binaryQF(1, 1, -1, bound, "primitively")
doc"""
Return primes represented by the integer binary quadratic form ``x^2+xy-y^2``.
"""
B141158(bound::Int) = binaryQF(1, 1, -1, bound, "prime")
doc"""
Return primes congruent to ``{0, 1, 4}`` mod 5. (Cf. also A141158)
"""
B038872(bound::Int) = binaryQF(1, 1, -1, bound, "prime")
doc"""
Return positive integers not congruent to 2 mod 4; regular numbers modulo 4.
"""
B042965(bound::Int) = binaryQF(1, 0, -1, bound) # "positive"
doc"""
Return numbers that are congruent to ``{0, 1, 3, 5, 7}`` mod 8.
Positive integers represented by the binary quadratic form ``x^2-y^2``
with ``x`` and ``y`` relatively prime.
"""
B047486(bound::Int) = binaryQF(1, 0, -1, bound, "primitively")
doc"""
Return positive integers of the form ``x^2 + xy + y^2`` (Loeschian numbers).
"""
B003136(bound::Int) = binaryQF(1, 1, 1, bound) # "positive"
doc"""
Return positive integers that are primitively represented by ``x^2 + xy + y^2``.
"""
B034017(bound::Int) = binaryQF(1, 1, 1, bound, "primitively")
doc"""
Return primes that are represented by ``x^2 + xy + y^2`` (generalized cuban primes).
"""
B007645(bound::Int) = binaryQF(1, 1, 1, bound, "prime")
doc"""
Return positive integers that are the sum of 2 squares.
"""
B001481(bound::Int) = binaryQF(1, 0, 1, bound) # "positive"
doc"""
Return numbers ``n`` that are primitively represented by ``x^2 + y^2``.
Also numbers n such that ``√(-1)`` mod ``n`` exists.
"""
B008784(bound::Int) = binaryQF(1, 0, 1, bound, "primitively")
doc"""
Return primes of form ``x^2 + y^2``; or primes congruent to 1 or 2 modulo 4.
"""
B002313(bound::Int) = binaryQF(1, 0, 1, bound, "prime")
doc"""
Return Pythagorean primes: primes of form ``4n + 1``.
"""
B002144(bound::Int) = binaryQF(1, 0, 1, bound, "prime")
doc"""
Return positive integers of the form ``x^2+xy+2y^2`` with ``x`` and ``y`` integers.
See also A035248.
"""
B028951(bound::Int) = binaryQF(1, 1, 2, bound) # "positive"
doc"""
Return positive numbers primitively represented by the binary quadratic form (1, 1, 2).
"""
B244779(bound::Int) = binaryQF(1, 1, 2, bound, "primitively")
doc"""
Return primes represented by the binary quadratic form (1, 1, 2). Primes congruent
to ``{0, 1, 2, 4}`` mod 7.
"""
B045373(bound::Int) = binaryQF(1, 1, 2, bound, "prime")
doc"""
Return primes of form ``x^2+7*y^2``.
"""
B033207(bound::Int) = binaryQF(1, 1, 2, bound, "prime")
doc"""
Return integers of form ``x^2 + 2y^2``.
"""
B002479(bound::Int) = binaryQF(1, 0, 2, bound)
doc"""
Return positive integers primitively represented by ``x^2 + 2y^2``.
"""
B057127(bound::Int) = binaryQF(1, 0, 2, bound, "primitively")
doc"""
Return primes of form ``x^2+2*y^2``. Primes congruent to ``{1, 2, 3}`` mod 8.
"""
B033203(bound::Int) = binaryQF(1, 0, 2, bound, "prime")
doc"""
Return odd primes of form ``x^2+2*y^2``. Primes congruent to ``{1, 3}`` mod 8.
"""
B033200(bound::Int) = binaryQF(1, 0, 2, bound, "prime")
doc"""
Return positive numbers represented by the binary quadratic form (1,1,3).
(See also A028954.)
"""
B035247(bound::Int) = binaryQF(1, 1, 3, bound) # "positive"
doc"""
Return positive numbers primitively represented by the binary quadratic form (1,1,3).
"""
B244780(bound::Int) = binaryQF(1, 1, 3, bound, "primitively")
doc"""
Return primes of form ``x^2+xy+3y^2``, discriminant -11.
"""
B056874(bound::Int) = binaryQF(1, 1, 3, bound, "prime")
doc"""
Return positive numbers primitively represented by the binary quadratic form (1,0,3).
"""
B244819(bound::Int) = binaryQF(1, 0, 3, bound, "primitively")
doc"""
Return positive integers of the form ``x^2+6xy-3y^2``.
"""
B243168(bound::Int) = binaryQF(1, 6, -3, bound)
doc"""
Return positive numbers primitively represented by the binary quadratic form (1,6,-3).
"""
B244291(bound::Int) = binaryQF(1, 6, -3, bound, "primitively")
doc"""
Return primes of the form ``8n+7``, that is, primes congruent to -1 mod 8.
"""
B007522(bound::Int) = binaryQF(-1, 4, 4, bound, "prime")
# +++ Clausen.jl +++
doc"""
Return the Clausen number ``C_n`` which is the denominator of the Bernoulli
number ``B_{2n}``.
"""
function ClausenNumber(n::Int)
    n == 0 && return ZZ(1)
    m = [d + 1 for d in Divisors(2n)]
    ∏([q for q in m if IsPrime(q)])
end
doc"""
Return the list of length len of Clausen numbers which are the denominators of
the Bernoulli numbers ``B_{2n}``.
"""
function ClausenNumberList(len::Int)
    len ≤ 0 && return fmpz[]
    A = FillArray(2, len); A[0] = 1
    m = len - 1
    m == 0 && return A
    for p in Primes(3, 2m + 1)
        r = Int(div(p - 1, 2))
        for k in range(r, r, div(m, r))
            A[k] *= p
        end
    end
    A
end
doc"""
Return the Clausen number ``C(n)`` which is the denominator of the Bernoulli
number ``B_{2n}``.
"""
A002445(n::Int) = ClausenNumber(n)
doc"""
Return the list of length len of Clausen numbers which are the denominators
of the Bernoulli numbers ``B_{2n}``.
"""
L002445(len::Int) = ClausenNumberList(len)
doc"""
Return the denominator of Bernoulli number ``B_n``.
"""
function A027642(n::Int)
    IsEven(n) && return ClausenNumber(div(n, 2))
    n == 1 && return ZZ(2)
    return ZZ(1)
end
# +++ CombinationsIterator.jl +++
import Base: start, next, done, length, eltype
immutable Combinations{T}
    a::T
    t::Int
end
start(c::Combinations) = [1:c.t;]
function next(c::Combinations, s)
    comb = [c.a[si] for si in s]
    if c.t == 0
        return (comb, [length(c.a) + 2])
    end
    s = copy(s)
    for i = length(s):-1:1
        s[i] += 1
        if s[i] > (length(c.a) - (length(s)-i))
            continue
        end
        for j = i+1:endof(s)
            s[j] = s[j - 1] + 1
        end
        break
    end
    (comb,s)
end
done(c::Combinations, s) = !isempty(s) && s[1] > length(c.a) - c.t + 1
length(c::Combinations) = binomial(length(c.a), c.t)
eltype{T}(::Type{Combinations{T}}) = Vector{eltype(T)}
"""
Generate all combinations of `n` elements from an indexable object. Because the
number of combinations can be very large, this function returns an iterator object.
Use `collect(combinations(array,n))` to get an array of all combinations.
"""
function combinations(a, t::Integer)
    if t < 0
        t = length(a) + 1
    end
    Combinations(a, t)
end
"""
Generate combinations of all orders, chaining of order iterators is eager,
but sequence at each order is lazy.
"""
combinations(a) = IterTools.chain([combinations(a, k) for k=1:length(a)]...)
# +++ Counts.jl +++
doc"""
Return a list of composite numbers of length len.
(Numbers which have more than one prime divisor.)
julia> L002808(8)
[4, 6, 8, 9, 10, 12, 14, 15]
"""
L002808(len) = List(len, IsComposite)
doc"""
Return a list of the number of composite numbers ``≤ n``.
julia> L065855(8)
[0, 0, 0, 0, 1, 1, 2, 2]
"""
L065855(len) = CountList(len, IsComposite)
doc"""
Return a list of squarefree numbers of length len.
(Numbers which are not divisible by a square greater than 1.)
julia> L005117(8)
[1, 2, 3, 5, 6, 7, 10, 11]
"""
L005117(len) = List(len, IsSquareFree)
doc"""
Return a list of the number of squarefree numbers ``< n``.
julia> L013928(8)
[0, 1, 2, 3, 3, 4, 5, 6]
"""
L013928(len) = CountList(len, IsSquareFree)
doc"""
Return a list of powers of primes of length len.
(Numbers of the form ``p^k`` where ``p`` is a prime and ``k ≥ 0``.)
julia> L000961(8)
[1, 2, 3, 4, 5, 7, 8, 9]
"""
L000961(len) = List(len, IsPowerOfPrimes)
doc"""
Return the number of powers of primes ``≤ n``. (Powers of primes are numbers
of the form ``p^k`` where ``p`` is a prime and ``k ≥ 0``.)
julia> L065515(8)
[0, 1, 2, 3, 4, 5, 5, 6]
"""
L065515(len) = CountList(len, IsPowerOfPrimes)
doc"""
Return a list of prime powers of length len.
(Numbers of the form ``p^k`` where ``p`` is a prime and ``k ≥ 1``.)
julia> L246655(8)
[2, 3, 4, 5, 7, 8, 9, 11]
"""
L246655(len) = List(len, IsPrimePower)
doc"""
Return a list of the number of prime powers ``≤ n`` with exponents ``k ≥ 1``.
julia> L025528(8)
[0, 0, 1, 2, 3, 4, 4, 5]
"""
L025528(len) = CountList(len, IsPrimePower)
doc"""
Return a list of perfect powers of length len.
(Numbers of the form ``p^k`` where ``p`` is a prime and ``k ≥ 2``.
julia> L246547(8)
[4, 8, 9, 16, 25, 27, 32, 49]
"""
L246547(len) = List(len, IsPerfectPower)
doc"""
Return a list of the number of prime powers ``≤ n`` with exponents ``k ≥ 2``.
julia> L069637(8)
[0, 0, 0, 0, 1, 1, 1, 1]
"""
L069637(len) = CountList(len, IsPerfectPower)
doc"""
Return the largest prime in ``N`` (the semiring of natural numbers including zero)
less than n for ``n ≥ 0``. (The "prev_prime" function of Mathematica, Maple,
Magma and SageMath.)
"""
A007917(n::Int) = Previous(n, IsPrime)
doc"""
Return the largest prime in ``Z`` (the ring of all integers)
less than ``n`` for ``n ≥ 0``. Cf. A007917.
"""
PreviousPrime(n::Int) = n ∈ [0, 1, 2] ? -2 : Previous(n - 1, IsPrime)
doc"""
Return least prime ``> n``. The "next_prime" function of Mathematica, Maple,
Magma and SageMath. Cf. A151800.
"""
NextPrime(n::Int) = Next(n, IsPrime)
doc"""
Return least prime ``> n``. The "next_prime" function of Mathematica, Maple,
Magma and SageMath.
"""
A151800(n::Int) = Next(n, IsPrime)
doc"""
Return the list of number of primes ``≤ n`` for ``n ≥ 0``.
julia> PrimePiList(8)
[0, 0, 1, 2, 2, 3, 3, 4]
"""
PrimePiList(len::Int) = CountList(len, IsPrime)
doc"""
Return the list of number of primes ``≤ n`` for ``n ≥ 0``.
julia> L000720(8)
[0, 0, 1, 2, 2, 3, 3, 4]
"""
L000720(len::Int) = PrimePiList(len)
doc"""
Return the index of the least prime not dividing n.
"""
function A257993(n::Int)
    c, p = 1, 2
    while n % p == 0
        p = NextPrime(p)
        c += 1
    end
    c
end
# +++ DedekindEta.jl +++
doc"""
Compute the ``q``-expansion to length len of the Dedekind ``η`` function (without
the leading factor ``q^{1/24}``) raised to the power ``r``, i.e.
``$ (q^{-1/24} η(q))^r = ∏_{k ≥ 1} (1 - q^k)^r. $``
In particular, ``r = -1`` returns the generating function of the Partition
function ``p(k)`` and ``r = 24`` gives the Ramanujan tau function ``τ(k)``.
"""
function DedekindEtaPowers(len::Int, r::Int)
    len ≤ 0 && return fmpz[]
    R, x = PolynomialRing(ZZ, "x")
    e = eta_qexp(r, len, x)
    SeqArray([coeff(e, j) for j in 0:len - 1])
end
doc"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)``.
"""
L010815(len::Int) = DedekindEtaPowers(len, 1)
doc"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^2``.
"""
L002107(len::Int) = DedekindEtaPowers(len, 2)
doc"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^3``.
"""
L010816(len::Int) = DedekindEtaPowers(len, 3)
doc"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^4``.
"""
L000727(len::Int) = DedekindEtaPowers(len, 4)
doc"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^5``.
"""
L000728(len::Int) = DedekindEtaPowers(len, 5)
doc"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^6``.
"""
L000729(len::Int) = DedekindEtaPowers(len, 6)
doc"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^7``.
"""
L000730(len::Int) = DedekindEtaPowers(len, 7)
doc"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^8``.
"""
L000731(len::Int) = DedekindEtaPowers(len, 8)
doc"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^9``.
"""
L010817(len::Int) = DedekindEtaPowers(len, 9)
doc"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{10}``.
"""
L010818(len::Int) = DedekindEtaPowers(len, 10)
doc"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{11}``.
"""
L010819(len::Int) = DedekindEtaPowers(len, 11)
doc"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{12}``.
"""
L000735(len::Int) = DedekindEtaPowers(len, 12)
doc"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{13}``.
"""
L010820(len::Int) = DedekindEtaPowers(len, 13)
doc"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{14}``.
"""
L010821(len::Int) = DedekindEtaPowers(len, 14)
doc"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{15}``.
"""
L010822(len::Int) = DedekindEtaPowers(len, 15)
doc"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{16}``.
"""
L000739(len::Int) = DedekindEtaPowers(len, 16)
doc"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{17}``.
"""
L010823(len::Int) = DedekindEtaPowers(len, 17)
doc"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{18}``.
"""
L010824(len::Int) = DedekindEtaPowers(len, 18)
doc"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{19}``.
"""
L010825(len::Int) = DedekindEtaPowers(len, 19)
doc"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{20}``.
"""
L010826(len::Int) = DedekindEtaPowers(len, 20)
doc"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{21}``.
"""
L010827(len::Int) = DedekindEtaPowers(len, 21)
doc"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{22}``.
"""
L010828(len::Int) = DedekindEtaPowers(len, 22)
doc"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{23}``.
"""
L010829(len::Int) = DedekindEtaPowers(len, 23)
doc"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{24}``.
"""
L000594(len::Int) = DedekindEtaPowers(len, 24)
doc"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{25}``.
"""
L010830(len::Int) = DedekindEtaPowers(len, 25)
doc"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{26}``.
"""
L010831(len::Int) = DedekindEtaPowers(len, 26)
doc"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{27}``.
"""
L010832(len::Int) = DedekindEtaPowers(len, 27)
doc"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{28}``.
"""
L010833(len::Int) = DedekindEtaPowers(len, 28)
doc"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{29}``.
"""
L010834(len::Int) = DedekindEtaPowers(len, 29)
doc"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{30}``.
"""
L010835(len::Int) = DedekindEtaPowers(len, 30)
doc"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{31}``.
"""
L010836(len::Int) = DedekindEtaPowers(len, 31)
doc"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{32}``.
"""
L010837(len::Int) = DedekindEtaPowers(len, 32)
doc"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{40}``.
"""
L010840(len::Int) = DedekindEtaPowers(len, 40)
doc"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{44}``.
"""
L010838(len::Int) = DedekindEtaPowers(len, 44)
doc"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{48}``.
"""
L010839(len::Int) = DedekindEtaPowers(len, 48)
doc"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{64}``.
"""
L010841(len::Int) = DedekindEtaPowers(len, 64)
doc"""
List of the first values of the Ramanujan tau function.
"""
RamanujanTauList(len::Int) = DedekindEtaPowers(len, 24)
doc"""
Return Ramanujan's tau(n).
"""
RamanujanTau(n::Int) = DedekindEtaPowers(n, 24)[end]
doc"""
Return the number of partitions of n.
"""
PartitionNumberList(len::Int) = DedekindEtaPowers(len, -1)
doc"""
Return the number of partitions of n.
"""
L000041(len::Int) = DedekindEtaPowers(len, -1)
doc"""
Return the number of partitions of n into parts of 2 kinds.
"""
L000712(len::Int) = DedekindEtaPowers(len, -2)
doc"""
Return the number of partitions of n into parts of 3 kinds.
"""
L000716(len::Int) = DedekindEtaPowers(len, -3)
doc"""
Return the number of partitions of n into parts of 4 kinds.
"""
L023003(len::Int) = DedekindEtaPowers(len, -4)
doc"""
Return the number of partitions of n into parts of 5 kinds.
"""
L023004(len::Int) = DedekindEtaPowers(len, -5)
doc"""
Return the number of partitions of n into parts of 6 kinds.
"""
L023005(len::Int) = DedekindEtaPowers(len, -6)
doc"""
Return the number of partitions of n into parts of 7 kinds.
"""
L023006(len::Int) = DedekindEtaPowers(len, -7)
doc"""
Return the number of partitions of n into parts of 8 kinds.
"""
L023007(len::Int) = DedekindEtaPowers(len, -8)
doc"""
Return the number of partitions of n into parts of 9 kinds.
"""
L023008(len::Int) = DedekindEtaPowers(len, -9)
doc"""
Return the number of partitions of n into parts of 10 kinds.
"""
L023009(len::Int) = DedekindEtaPowers(len, -10)
doc"""
Return the number of partitions of n into parts of 11 kinds.
"""
L023010(len::Int) = DedekindEtaPowers(len, -11)
doc"""
Return the number of partitions of n into parts of 12 kinds.
"""
L005758(len::Int) = DedekindEtaPowers(len, -12)
doc"""
Return the number of partitions of n into parts of 13 kinds.
"""
L023011(len::Int) = DedekindEtaPowers(len, -13)
doc"""
Return the number of partitions of n into parts of 14 kinds.
"""
L023012(len::Int) = DedekindEtaPowers(len, -14)
doc"""
Return the number of partitions of n into parts of 15 kinds.
"""
L023013(len::Int) = DedekindEtaPowers(len, -15)
doc"""
Return the number of partitions of n into parts of 16 kinds.
"""
L023014(len::Int) = DedekindEtaPowers(len, -16)
doc"""
Return the number of partitions of n into parts of 17 kinds.
"""
L023015(len::Int) = DedekindEtaPowers(len, -17)
doc"""
Return the number of partitions of n into parts of 18 kinds.
"""
L023016(len::Int) = DedekindEtaPowers(len, -18)
doc"""
Return the number of partitions of n into parts of 19 kinds.
"""
L023017(len::Int) = DedekindEtaPowers(len, -19)
doc"""
Return the number of partitions of n into parts of 20 kinds.
"""
L023018(len::Int) = DedekindEtaPowers(len, -20)
doc"""
Return the number of partitions of n into parts of 21 kinds.
"""
L023019(len::Int) = DedekindEtaPowers(len, -21)
doc"""
Return the number of partitions of n into parts of 22 kinds.
"""
L023020(len::Int) = DedekindEtaPowers(len, -22)
doc"""
Return the number of partitions of n into parts of 23 kinds.
"""
L023021(len::Int) = DedekindEtaPowers(len, -23)
doc"""
Return the number of partitions of n into parts of 24 kinds.
"""
L006922(len::Int) = DedekindEtaPowers(len, -24)
doc"""
Return the number of partitions of n into parts of 30 kinds.
"""
L082556(len::Int) = DedekindEtaPowers(len, -30)
doc"""
Return the number of partitions of n into parts of 32 kinds.
"""
L082557(len::Int) = DedekindEtaPowers(len, -32)
doc"""
Return the number of partitions of n into parts of 48 kinds.
"""
L082558(len::Int) = DedekindEtaPowers(len, -48)
doc"""
Return the number of partitions of n into parts of 64 kinds.
"""
L082559(len::Int) = DedekindEtaPowers(len, -64)
# +++ Deleham.jl +++
doc"""
Return the product of two integer sequences introduced by Philippe Deléham in
A084938.
"""
function DeléhamΔ(n::Int, S::Function, T::Function)
    n ≤ 0 && return fmpz[]
    R, x = PolynomialRing(ZZ, "x")
    A = [R(S(k) + x * T(k)) for k in 0:n - 2]
    C = [R(1) for i in 0:n]; C[1] = R(0)
    len = div((n + 1) * n, 2)
    M = SeqArray(len)
    m = 0
    for k in 0:n - 1
        for j in k + 1:-1:2
            C[j] = C[j - 1] + C[j + 1] * A[j - 1]
        end
        for j in 0:k
            M[m] = coeff(C[2], j)
            m += 1
        end
    end
    M
end
doc"""
Return the number of permutations of ``{1,2,...,n}`` having ``k`` cycles such that the
elements of each cycle of the permutation form an interval. (Ran Pan)
"""
T084938(n::Int) = DeléhamΔ(n, i -> div(i + 1, 2), i -> 0^i)
doc"""
Return the number of lattice paths from ``(0,0)`` to ``(x,y)`` that never pass below ``y = x``
and use step set ``{(0,1), (1,0), (2,0), (3,0), ...}``.
"""
T011117(n::Int) = DeléhamΔ(n, i -> 0^i, i -> IsOdd(i) ? 1 : (i > 0 ? 2 : 0))
doc"""
Return the number of Schroeder paths (i.e., consisting of steps ``U=(1,1), D=(1,-1), H=(2,0)``
and never going below the x-axis) from ``(0,0)`` to ``(2n,0)``, having ``k`` peaks.
(Emeric Deutsch)
"""
T060693(n::Int) = DeléhamΔ(n, i -> 1, i -> IsOdd(i) ? 0 : 1)
doc"""
Return the the Catalan convolution triangle.
"""
T106566(n::Int) = DeléhamΔ(n, i -> i == 0 ? 0 : 1, i -> i == 0 ? 1 : 0)
doc"""
Return the number of increasing 0-2 trees (A002105) on 2n edges in which the minimal path
from the root has length k. (David Callan)
"""
T094665(n::Int) = DeléhamΔ(n, i -> div(i * (i + 1), 2), i -> i + 1)
doc"""
Return the number of lists of k unlabeled permutations whose total length is n. (David Callan)
"""
T090238(n::Int) = DeléhamΔ(n, i -> div(i, 2) + (IsOdd(i) ? 2 : 0), i -> i == 0 ? 1 : 0)
doc"""
Return the triangle ``4^k S_4(n, k)`` where ``S_m(n, k)`` are the Stirling-Frobenius cycle
numbers of order m.
"""
T225478(n::Int) = DeléhamΔ(n, i -> 2(i + 1) + (i + 1) % 2, i -> IsOdd(i) ? 0 : 4)
doc"""
Return the exponential transform of Pascal's triangle.
"""
T055883(n::Int) = DeléhamΔ(n, i -> IsOdd(i) ? div(i + 1, 2) : 1, i -> IsOdd(i) ? div(i + 1, 2) : 1)
doc"""
Return the number of Schroeder paths of length ``2n`` and having ``k`` ascents.
"""
T090981(n::Int) = DeléhamΔ(n, i -> i == 0 ? 1 : (IsOdd(i) ? 0 : 2), i -> IsOdd(i) ? 1 : 0)
doc"""
Return a triangle related to the median Euler numbers.
"""
T088969(n::Int) = DeléhamΔ(n, i -> i^2, i -> IsOdd(i) ? 3div(i, 2) + 2 : 5div(i, 2) + 1)
doc"""
Return the Bell transform of the Fubini numbers.
"""
T184962(n::Int) = DeléhamΔ(n, i -> div((i + 1) - (i + 1) % 2, 2 - (i + 1) % 2), i -> IsOdd(i) ? 0 : 1)
# +++ Derangements.jl +++
doc"""
Return the number of fixpoit free permutations of an n-set.
"""
function Derangement(n)
    prec = 250
    while prec < 10000
        CC = AcbField(prec)
        c = exp(CC(-1)) * Nemo.gamma(CC(n+1), CC(-1))
        b, i = unique_integer(c)
        b && return i
        prec *= 2
    end
    println("n = $n gives an InexactError!")
end
doc"""
Return the number of fixpoit free permutations of an n-set.
"""
Subfactorial(n) = Derangement(n)
doc"""
Return the number of fixpoit free permutations of an n-set.
"""
A000166(n) = Derangement(n)
doc"""
Return the number of fixpoit free permutations of an n-set beginning with 2.
"""
function A000255(n)
    prec = 250
    while prec < 10000
        CC = AcbField(prec)
        c = exp(CC(-1)) * Nemo.gamma(CC(n+3), CC(-1)) / CC(n+1)
        b, i = unique_integer(c)
        b && return i
        prec *= 2
    end
    println("n = $n gives an InexactError!")
end
doc"""
Return the number of derangements of a set of n + 2 elements such that the first
two elements belong to distinct cycles. (I. Mezo)
"""
function A105927(n)
    prec = 250
    while prec < 10000
        CC = AcbField(prec)
        c = (CC(n^2+n-1)*exp(CC(-1)) * Nemo.gamma(CC(n+1),CC(-1)) - (-1)^n*CC(n-1))/CC(2)
        b, i = unique_integer(c)
        b && return i
        prec *= 2
    end
    println("n = $n gives an InexactError!")
end
# +++ Fibonacci.jl +++
doc"""
Return the generalized Fibonacci numbers which are defined recursively
``$F(n,k) = F(n-1,k) + kF(n-2,k), F(0,k) = 0, F(1,k) = 1.$``
"""
function FibonacciGeneralized(n::Int, k::Int)
    F = BigInt[1 k; 1 0]
    Fn = F^n
    fmpz(Fn[2, 1])
end
doc"""
Return the Jacobsthal numbers ``J(n) = F(n,2)`` where ``F(n,k)`` are the
generalized Fibonacci numbers.
"""
JacobsthalNumber(n::Int) = FibonacciGeneralized(n, 2)
doc"""
Return the Fibonacci numbers.
"""
FibonacciNumber(n::Int) = FibonacciGeneralized(n, 1)
doc"""
Return the Fibonacci numbers.
"""
A000045(n::Int) = FibonacciGeneralized(n, 1)
doc"""
Return the Jacobsthal numbers.
"""
A001045(n::Int) = FibonacciGeneralized(n, 2)
doc"""
Return the number of length-n strings with letters ``{0,1,2,3}`` where no two
consecutive letters are nonzero. (Joerg Arndt)
"""
A006130(n::Int) = FibonacciGeneralized(n, 3)
doc"""
Return the number of length-n strings with letters ``{0,1,2,3,4}`` where no two
consecutive letters are nonzero. (Joerg Arndt)
"""
A006131(n::Int) = FibonacciGeneralized(n, 4)
doc"""
Return the number of length-n strings with letters ``{0,1,2,3,4,5}`` where no
two consecutive letters are nonzero. (Joerg Arndt)
"""
A015440(n::Int) = FibonacciGeneralized(n, 5)
doc"""
Return the number of length-n strings with letters ``{0,1,2,...,6}`` where no
two consecutive letters are nonzero. (Joerg Arndt)
"""
A015441(n::Int) = FibonacciGeneralized(n, 6)
doc"""
Return the number of length-n strings with letters ``{0,1,2,...,7}`` where no
two consecutive letters are nonzero. (Joerg Arndt)
"""
A015442(n::Int) = FibonacciGeneralized(n, 7)
doc"""
Return the number of length-n strings with letters ``{0,1,2,...,8}`` where no
two consecutive letters are nonzero. (Joerg Arndt)
"""
A015443(n::Int) = FibonacciGeneralized(n, 8)
doc"""
Return the number of length-n strings with letters ``{0,1,2,...,9}`` where no
two consecutive letters are nonzero. (Joerg Arndt)
"""
A015445(n::Int) = FibonacciGeneralized(n, 9)
doc"""
Return the square array of generalized Fibonacci numbers, read by antidiagonals.
"""
A083856(r::Int, n::Int) = FibonacciGeneralized(n, r)
doc"""
Return the list of the first ``n`` terms of the generalized Fibonacci numbers
of order r.
"""
function FibonacciGeneralizedList(len::Int, r::Int)
    len ≤ 0 && return fmpz[]
    len < 2 && return [ZZ(i) for i in 0:len - 1]
    R = Array{fmpz}(len)
    R[1] = ZZ(0); R[2] = ZZ(1)
    for i in 3:len
        R[i] = R[i - 1] + r * R[i - 2]
    end
    R
end
doc"""
Return the list of the first ``n`` terms of the Fibonacci numbers.
"""
FibonacciNumberList(len::Int) = FibonacciGeneralizedList(len, 1)
doc"""
Return the list of the first ``n`` terms of the generalized Fibonacci numbers
of order 2.
"""
JacobsthalNumberList(len::Int) = FibonacciGeneralizedList(len, 2)
doc"""
Return the list of the first ``n`` terms of the Fibonacci numbers.
"""
L000045(len::Int) = FibonacciGeneralizedList(len, 1)
doc"""
Return the list of the first ``n`` terms of the Jacobsthal numbers.
"""
L001045(len::Int) = FibonacciGeneralizedList(len, 2)
doc"""
Return the list of the first ``n`` terms of the generalized Fibonacci numbers
of order 3.
"""
L006130(len::Int) = FibonacciGeneralizedList(len, 3)
doc"""
Return the list of the first ``n`` terms of the generalized Fibonacci numbers
of order 4.
"""
L006131(len::Int) = FibonacciGeneralizedList(len, 4)
doc"""
Return the list of the first ``n`` terms of the generalized Fibonacci numbers
of order 5.
"""
L015440(len::Int) = FibonacciGeneralizedList(len, 5)
doc"""
Return the list of the first ``n`` terms of the generalized Fibonacci numbers
of order 6.
"""
L015441(len::Int) = FibonacciGeneralizedList(len, 6)
doc"""
Return the list of the first ``n`` terms of the generalized Fibonacci numbers
of order 7.
"""
L015442(len::Int) = FibonacciGeneralizedList(len, 7)
doc"""
Return the list of the first ``n`` terms of the generalized Fibonacci numbers
of order 8.
"""
L015443(len::Int) = FibonacciGeneralizedList(len, 8)
doc"""
Return the list of the first ``n`` terms of the generalized Fibonacci numbers
of order 9.
"""
L015445(len::Int) = FibonacciGeneralizedList(len, 9)
# +++ FigurativeNumbers.jl +++
doc"""
Return the polygonal number with shape k.
"""
function PolygonalNumber(n, k)
    s = div(n^2 * (k - 2) - n * (k - 4), 2)
    k < 2 ? -s : s
end
doc"""
Return the pyramidal number with shape k.
"""
function PyramidalNumber(n, k)
    s = div(3 * n^2 + n^3 * (k - 2) - n * (k - 5), 6)
    k < 2 ? -s : s
end
doc"""
Return the polygonal numbers of shape -2.
"""
A014107(n) = PolygonalNumber(n, -2)
doc"""
Return the polygonal numbers of shape -1.
"""
A095794(n) = PolygonalNumber(n, -1)
doc"""
Return the polygonal numbers of shape 0.
"""
A067998(n) = PolygonalNumber(n, 0)
doc"""
Return the polygonal numbers of shape 1.
"""
A080956(n) = PolygonalNumber(n, 1)
doc"""
Return the polygonal numbers of shape 2 (these are the natural numbers).
"""
A001477(n) = PolygonalNumber(n, 2)
doc"""
Return the polygonal numbers of shape 3 (the triangular numbers).
"""
A000217(n) = PolygonalNumber(n, 3)
doc"""
Return the polygonal numbers of shape 4 (the squares).
"""
A000290(n) = PolygonalNumber(n, 4)
doc"""
Return the polygonal numbers of shape 5 (the pentagonal numbers).
"""
A000326(n) = PolygonalNumber(n, 5)
doc"""
Return the polygonal numbers of shape 6 (the hexagonal numbers).
"""
A000384(n) = PolygonalNumber(n, 6)
doc"""
Return the polygonal numbers of shape 7 (the heptagonal numbers).
"""
A000566(n) = PolygonalNumber(n, 7)
doc"""
Return the polygonal numbers of shape 8 (the octagonal numbers).
"""
A000567(n) = PolygonalNumber(n, 8)
doc"""
Return the polygonal numbers of shape 9 (the nonagonal numbers).
"""
A001106(n) = PolygonalNumber(n, 9)
doc"""
Return the polygonal numbers of shape 10 (decagonal numbers).
"""
A001107(n) = PolygonalNumber(n, 10)
doc"""
Return the pyramidal numbers of shape -1.
"""
A005564(n) = PyramidalNumber(n, -1)
doc"""
Return the pyramidal numbers of shape 0.
"""
A058373(n) = PyramidalNumber(n, 0)
doc"""
Return the pyramidal numbers of shape 1.
"""
A254749(n) = PyramidalNumber(n, 1)
doc"""
Return the pyramidal numbers of shape 3 (tetrahedral numbers).
"""
A000292(n) = PyramidalNumber(n, 3)
doc"""
Return the pyramidal numbers of shape 4 (square pyramidal numbers).
"""
A000330(n) = PyramidalNumber(n, 4)
doc"""
Return the pyramidal numbers of shape 5 (pentagonal pyramidal numbers).
"""
A002411(n) = PyramidalNumber(n, 5)
doc"""
Return the pyramidal numbers of shape 6 (hexagonal pyramidal numbers).
"""
A002412(n) = PyramidalNumber(n, 6)
doc"""
Return the pyramidal numbers of shape 7 (heptagonal pyramidal numbers).
"""
A002413(n) = PyramidalNumber(n, 7)
doc"""
Return the pyramidal numbers of shape 8 (octagonal pyramidal numbers).
"""
A002414(n) = PyramidalNumber(n, 8)
doc"""
Return the pyramidal numbers of shape 9 (enneagonal pyramidal numbers).
"""
A007584(n) = PyramidalNumber(n, 9)
doc"""
Return the pyramidal numbers of shape 10 (decagonal pyramidal numbers).
"""
A007585(n) = PyramidalNumber(n, 10)
# +++ GaussFactorial.jl +++
doc"""
Return ``∏_{1 ≤ j ≤ N, j ⊥ n} j``, the product of the positive integers which
are ``≤ N`` and are prime to ``n``.
"""
GaußFactorial(N::Int, n::Int) = n == 0 ? 0 : ∏([j for j in 1:N if ⊥(j, n)])
doc"""
Return ``∏_{1 ≤ j ≤ N, j ⊥ n} j``, the product of the positive integers which
are ``≤ N`` and are prime to ``n``.
"""
A216919(N::Int, n::Int) = GaußFactorial(N, n)
doc"""
Return ``∏_{1 ≤ j ≤ n, j ⊥ n} j``, the product of the positive integers which
are ``≤ n`` and are prime to ``n``.
"""
A001783(n::Int) = GaußFactorial(n, n)
doc"""
Return a list of the first len terms of A001783.
"""
L001783(len::Int) = SeqArray(len, A001783)
doc"""
Return the product of the positive integers which are ``≤ n/2`` and are
prime to ``n``.
"""
A124441(n::Int) = GaußFactorial(div(n, 2), n)
doc"""
Return a list of the first len terms of A124441.
"""
L124441(len::Int) = SeqArray(len, A124441)
doc"""
Return the product of the positive integers which are ``≥ n/2`` and are
prime to ``n``.
"""
A124442(n::Int) = ∏([j for j in cld(n, 2):n if ⊥(j, n)])
doc"""
Return a list of the first len terms of A124442.
"""
L124442(len::Int) = SeqArray(len, A124442)
doc"""
Return the product of numbers ``≤ n`` that have a prime factor in common with ``n``.
"""
A066570(n::Int) = div(GaußFactorial(n, 1), GaußFactorial(n, n))
doc"""
The product of the residues in ``[1, n]`` relatively prime to n taken modulo n,
where the absolute representation of the integers modulo n is used.
A160377(n) = mod(GaußFactorial(n, n), n).
"""
function A160377(n::Int)
    r = 1
    for j in 1:n
        ⊥(j, n) && (r = mod(r * j, n))
    end
    r
end
doc"""
Return a list of the first len terms of A160377.
"""
L160377(len::Int) = SeqArray(len, A160377)
doc"""
Return the product of the residues in ``[1,n]`` which are prime to n taken
modulo n, where the symmetric (or minimal) representation of the integers
modulo n is used.
A103131(n) = mods(GaußFactorial(n, n), n).
"""
function A103131(n::Int)
    r = 1
    for j in 1:n
        ⊥(j, n) && (r = mods(r * j, n))
    end
    r
end
doc"""
Return a list of the first len terms of A103131.
"""
L103131(len::Int) = SeqArray(len, A103131)
doc"""
Return the 2-adic factorial function.
"""
A055634(n::Int) = (-1)^n * GaußFactorial(n, 2)
doc"""
Return lcm``_{1 ≤ j ≤ n, j ⊥ n} j``, the least common multiple of the positive
integers which are ``≤ n`` and are prime to ``n``.
"""
GaußLcm(N::Int, n::Int) = n == 0 ? 0 : lcm([j for j in 1:N if ⊥(j, n)])
doc"""
Return the least common multiple of integers less than and prime to n.
"""
A038610(n::Int) = GaußLcm(n, n)
doc"""
Return a list of the first len terms of A038610.
"""
L038610(len::Int) = SeqArray(len, A038610)
doc"""
Return ∏(COP(n)) / lcm(COP(n)) where COP(n) denotes the positive integers which
are ``≤ n`` and are prime to ``n``.
"""
function A128247(n::Int)
    COP = [j for j in 1:n if ⊥(j, n)]
    COP == [] ? 0 : div(∏(COP), lcm(COP))
end
doc"""
Return a list of the first len terms of A128247.
"""
L128247(len::Int) = SeqArray(len, A128247)
doc"""
Query if there exists a primitive root modulo ``n``.
"""
HasPrimitiveRoot(n::Int) = 0 < n ≤ 2 ? true : mods(GaußFactorial(n, n), n) == -1
doc"""
Return numbers that have a primitive root (the multiplicative group
modulo ``n`` is cyclic).
"""
B033948(bound::Int) = FindUpTo(bound, HasPrimitiveRoot)
doc"""
Query if the discriminant of the n-th cyclotomic polynomial is a square.
"""
HasNoPrimitiveRoot(n::Int) = n ≤ 2 ? false : mod(GaußFactorial(n, n), n) == 1
doc"""
Return numbers ``n`` such that the discriminant of the n-th cyclotomic polynomial
is a square.
"""
B033949(bound::Int) = FindUpTo(bound, HasNoPrimitiveRoot)
# +++ GeneralBinomial.jl +++
doc"""
The classical binomial coefficients defined for ``n≥0`` and ``0≤k≤n``
(a.k.a. Pascal's triangle).
"""
function Pascal(n::Int, k::Int)
    (k == 0 || k == n) && return 1
    if k > div(n, 2) k = n - k end
    nk = n - k
    factors = fmpz[]
    rootN = isqrt(n)
    for prime in Primes(2, n)
        if prime > nk
            push!(factors, prime)
            continue
        end
        prime > div(n, 2) && continue
        if prime > rootN
            (n % prime < k % prime) && push!(factors, prime)
            continue
        end
        r, N, K, p = 0, n, k, 1
        while N > 0
            r = N % prime < (K % prime + r) ? 1 : 0
            if r == 1 p *= prime end
            N = div(N, prime)
            K = div(K, prime)
        end
        p > 1 && push!(factors, p)
    end
    ∏(factors) end
doc"""
Pascal's triangle.
"""
function T007318(n::Int)
    T = SeqTriangle(n)
    j = 0
    for m in 0:n - 1, k in 0:m
        T[j] = binom(m, k)
        j += 1
    end
    T
end
doc"""
Return the extended binomial coefficients defined for all ``n ∈ Z`` and ``k ∈ Z``.
``$\binom{n}{k} = \lim\limits_{x \to 1}(Γ(n + x) / (Γ(k + x) Γ(n - k + x)))$``.
Behaves like the binomial function in Maple and Mathematica.
"""
function Binomial(n::Int, k::Int)
    0 ≤ k ≤ n  && return binom(n, k)
    k ≤ n <  0 && return binom(-k - 1, n - k) * (-1)^(n - k)
    n <  0 ≤ k && return binom(-n + k - 1, k) * (-1)^k
    ZZ(0)
end
# +++ Hyper1F1.jl +++
doc"""
Return ``Γ(a) 1F1(b, c, d).``
"""
function GammaHyp(a, b, c, d)
    prec = 500
    while prec <= 10000
        CC = AcbField(prec)
        c = gamma(CC(a)) * hyp1f1(CC(b), CC(c), CC(d))
        b, i = unique_integer(c)
        b && return i
        prec *= 2
    end
    println("$a $b $c $d gives an InexactError!")
end
doc"""
Return ``n!`` Hyper``1F1[1-n, 2, -1]``.
Number of partitions of ``{1,...,n}`` into any number of ordered subsets.
"""
A000262(n::Int) = n == 0 ? ZZ(1) : GammaHyp(n + 1, 1 - n, 2, -1)
doc"""
Return ``(2n)!`` Hyper``1F1[-n, -2n, -2]``.
Number of ways ``n`` couples can sit in a row without any spouses next to each other.
"""
A007060(n::Int) = n == 0 ? ZZ(1) : GammaHyp(2n + 1, -n, -2n, -2)
doc"""
Return ``(2n)!`` Hyper``1F1[-n, -2n, -1]``.
Number of acyclic orientations of the Turán graph ``T(2n,n)``. (Alois P. Heinz)
"""
A033815(n::Int) = n == 0 ? ZZ(1) : GammaHyp(2n + 1, -n, -2n, -1)
doc"""
Return ``(2n)!`` Hyper``1F1[-n, -2n, 1]``.
``\sum_{k=0..n} \binom{n}{k} (2n-k)!``.
"""
A099022(n::Int) = n == 0 ? ZZ(1) : GammaHyp(2n + 1, -n, -2n, 1)
doc"""
Return ``((2n)!/(n+1)!)`` Hyper``1F1[1-n, n+2, -1]``.
Egf. ``exp(x C(x)^2)`` where ``C(x) = 1 + xC(x)^2`` is the gf. of the Catalan numbers.
"""
function A251568(n::Int)
    n == 0 && return fmpz(1)
    prec = 500
    while prec <= 10000
        CC = AcbField(prec)
        c = gamma(CC(2 * n + 1)) * hyp1f1(CC(1 - n), CC(n + 2), CC(-1)) / gamma(CC(n + 2))
        b, i = unique_integer(c)
        b && return i
        prec *= 2
    end
    println("n = $n gives an InexactError!")
end
# +++ JacobiTheta.jl +++
doc"""
The ``q``-expansion to length len of the Jacobi theta function raised
to the power ``r``, i.e. ``ϑ(q)^r`` where ``ϑ(q) = 1 + ∑_{k ≥ 1} q^{k^2}``.
Number of ways of writing ``n`` as a sum of ``r`` squares.
"""
function JacobiTheta3Powers(len::Int, r::Int)
    len ≤ 0 && return fmpz[]
    R, x = PolynomialRing(ZZ, "x")
    e = theta_qexp(r, len, x)
    SeqArray([fmpz(coeff(e, j)) for j in 0:len - 1])
end
doc"""
Return the ``q``-expansion to length ``len`` of the Jacobi theta function raised
to the power ``r``, i.e. ``ϑ(-q)^r`` where ``$ϑ(q) = 1 + ∑_{k ≥ 1} q^{k^2} .$``
"""
function JacobiTheta4Powers(len::Int, r::Int)
    len ≤ 0 && return fmpz[]
    R, x = PolynomialRing(ZZ, "x")
    e = theta_qexp(r, len, -x)
    SeqArray([fmpz(coeff(e, j)) for j in 0:len - 1])
end
doc"""
Return the number of ways of writing a nonnegative integer n as a square.
"""
L000122(len::Int) = JacobiTheta3Powers(len, 1)
doc"""
Return the expansion of Jacobi theta function ``ϑ(-q)``.
"""
L002448(len::Int) = JacobiTheta4Powers(len, 1)
doc"""
Return the number of ways of writing a nonnegative integer n as a sum of 2 squares.
"""
L004018(len::Int) = JacobiTheta3Powers(len, 2)
doc"""
Return the expansion of ``ϑ_4(q)^2`` in powers of q.
"""
L104794(len::Int) = JacobiTheta4Powers(len, 2)
doc"""
Return the number of ways of writing a nonnegative integer n as a sum of 3 squares.
"""
L005875(len::Int) = JacobiTheta3Powers(len, 3)
doc"""
Return the expansion of ``ϑ_4(q)^3`` in powers of q.
"""
L213384(len::Int) = JacobiTheta4Powers(len, 3)
doc"""
Number of ways of writing a nonnegative integer n as a sum
of 4 squares.
"""
L000118(len::Int) = JacobiTheta3Powers(len, 4)
doc"""
Return the expansion of ``ϑ_4(q)^4`` in powers of q.
"""
L096727(len::Int) = JacobiTheta4Powers(len, 4)
doc"""
Return the number of ways of writing a nonnegative integer n as a sum
of 5 squares.
"""
L000132(len::Int) = JacobiTheta3Powers(len, 5)
doc"""
Return the number of ways of writing a nonnegative integer n as a sum
of 6 squares.
"""
L000141(len::Int) = JacobiTheta3Powers(len, 6)
doc"""
Return the nnumber of ways of writing a nonnegative integer n as a sum
of 7 squares.
"""
L008451(len::Int) = JacobiTheta3Powers(len, 7)
doc"""
Return the number of ways of writing a nonnegative integer n as a sum
of 8 squares.
"""
L000143(len::Int) = JacobiTheta3Powers(len, 8)
doc"""
Return the expansion of ``ϑ_4(q)^8`` in powers of q.
"""
L035016(len::Int) = JacobiTheta4Powers(len, 8)
doc"""
Return the number of ways of writing a nonnegative integer n as a sum
of 9 squares.
"""
L008452(len::Int) = JacobiTheta3Powers(len, 9)
doc"""
Return the number of ways of writing a nonnegative integer n as a sum
of 10 squares.
"""
L000144(len::Int) = JacobiTheta3Powers(len, 10)
doc"""
Return the number of ways of writing a nonnegative integer n as a sum
of 11 squares.
"""
L008453(len::Int) = JacobiTheta3Powers(len, 11)
doc"""
Return the number of ways of writing a nonnegative integer n as a sum
of 12 squares.
"""
L000145(len::Int) = JacobiTheta3Powers(len, 12)
doc"""
Return the number of ways of writing a nonnegative integer n as a sum
of 13 squares.
"""
L276285(len::Int) = JacobiTheta3Powers(len, 13)
doc"""
Return the number of ways of writing a nonnegative integer n as a sum
of 14 squares.
"""
L276286(len::Int) = JacobiTheta3Powers(len, 14)
doc"""
Return the nnumber of ways of writing a nonnegative integer n as a sum
of 15 squares.
"""
L276287(len::Int) = JacobiTheta3Powers(len, 15)
doc"""
Return the expansion of ``1/ϑ_3(q)`` in powers of q.
"""
L004402(len::Int) = JacobiTheta3Powers(len, -1)
doc"""
Return the expansion of ``1/ϑ_4(q)`` in powers of q.
"""
L015128(len::Int) = JacobiTheta4Powers(len, -1)
doc"""
Return the expansion of ``1/ϑ_3(q)^2`` in powers of q.
"""
L004403(len::Int) = JacobiTheta3Powers(len, -2)
doc"""
Return the expansion of ``1/ϑ_4(q)^2`` in powers of q.
"""
L001934(len::Int) = JacobiTheta4Powers(len, -2)
doc"""
Return the expansion of ``1/ϑ_3(q)^3`` in powers of q.
"""
L004404(len::Int) = JacobiTheta3Powers(len, -3)
doc"""
Return the expansion of ``1/ϑ_3(q)^4`` in powers of q.
"""
L004405(len::Int) = JacobiTheta3Powers(len, -4)
doc"""
Return the expansion of ``1/ϑ_3(q)^5`` in powers of q.
"""
L004406(len::Int) = JacobiTheta3Powers(len, -5)
doc"""
Return the expansion of ``1/ϑ_3(q)^6`` in powers of q.
"""
L004407(len::Int) = JacobiTheta3Powers(len, -6)
doc"""
Return the expansion of ``1/ϑ_3(q)^7`` in powers of q.
"""
L004408(len::Int) = JacobiTheta3Powers(len, -7)
doc"""
Return the expansion of ``1/ϑ_3(q)^8`` in powers of q.
"""
L004409(len::Int) = JacobiTheta3Powers(len, -8)
doc"""
Return the expansion of ``1/ϑ_3(q)^9`` in powers of q.
"""
L004410(len::Int) = JacobiTheta3Powers(len, -9)
doc"""
Return the expansion of ``1/ϑ_3(q)^{10}`` in powers of q.
"""
L004411(len::Int) = JacobiTheta3Powers(len, -10)
doc"""
Return the expansion of ``1/ϑ_3(q)^{11}`` in powers of q.
"""
L004412(len::Int) = JacobiTheta3Powers(len, -11)
doc"""
Return the expansion of ``1/ϑ_3(q)^{12}`` in powers of q.
"""
L004413(len::Int) = JacobiTheta3Powers(len, -12)
doc"""
Return the expansion of ``1/ϑ_3(q)^{13}`` in powers of q.
"""
L004414(len::Int) = JacobiTheta3Powers(len, -13)
doc"""
Return the expansion of ``1/ϑ_3(q)^{14}`` in powers of q.
"""
L004415(len::Int) = JacobiTheta3Powers(len, -14)
doc"""
Return the expansion of ``1/ϑ_3(q)^{15}`` in powers of q.
"""
L004416(len::Int) = JacobiTheta3Powers(len, -15)
doc"""
Return the expansion of ``1/ϑ_3(q)^{16}`` in powers of q.
"""
L004417(len::Int) = JacobiTheta3Powers(len, -16)
doc"""
Return the expansion of ``1/ϑ_3(q)^{17}`` in powers of q.
"""
L004418(len::Int) = JacobiTheta3Powers(len, -17)
doc"""
Return the expansion of ``1/ϑ_3(q)^{18}`` in powers of q.
"""
L004419(len::Int) = JacobiTheta3Powers(len, -18)
doc"""
Return the expansion of ``1/ϑ_3(q)^{19}`` in powers of q.
"""
L004420(len::Int) = JacobiTheta3Powers(len, -19)
doc"""
Return the expansion of ``1/ϑ_3(q)^{20}`` in powers of q.
"""
L004421(len::Int) = JacobiTheta3Powers(len, -20)
doc"""
Return the expansion of ``1/ϑ_3(q)^{21}`` in powers of q.
"""
L004422(len::Int) = JacobiTheta3Powers(len, -21)
doc"""
Return the expansion of ``1/ϑ_3(q)^{22}`` in powers of q.
"""
L004423(len::Int) = JacobiTheta3Powers(len, -22)
doc"""
Return the expansion of ``1/ϑ_3(q)^{23}`` in powers of q.
"""
L004424(len::Int) = JacobiTheta3Powers(len, -23)
doc"""
Return the expansion of ``1/ϑ_3(q)^{24}`` in powers of q.
"""
L004425(len::Int) = JacobiTheta3Powers(len, -24)
# +++ Kolakoski.jl +++
doc"""
Generates the Kolakoski sequence which is the unique sequence
over the alphabet ``{1, 2}`` starting with ``1`` and having the
sequence of run lengths identical with itself.
"""
C000002() = Channel(csize = 10) do c
    x = y = Int(-1)
    while true
        put!(c, [2, 1][(x & 1) + 1])
        f = y & ~(y + 1)
        x = xor(x, f)
        y = (y + 1) | (f & (x >> 1))
    end
end
doc"""
Return the list of the first ``n`` terms of the Kolakoski sequence.
"""
function KolakoskiList(len::Int)
    len ≤ 0 && return []
    generator = C000002()
    L = [take!(generator) for _ in 1:len]
    close(generator)
    L
end
doc"""
Return the list of the first ``n`` terms of the Kolakoski sequence.
"""
L000002(n::Int) = KolakoskiList(n)
# +++ Maxima.jl +++
doc"""
Return maxima relative to the predecessors and their positions of a sequence ``f``
as a pair of lists ``(r, i)`` where ``r`` contains the maxima and ``i`` the
index where they occur.
``f(0)`` is a maximum and ``f(i)`` is a maximum if ``f(j) < f(i)`` for all ``0 < j < i`` .
All maxima ≤ bound are returned. In the OEIS such values are often called
'record values'.
"""
function FindMaximaUpTo(bound::Int, f::Function)
    bound == 0 && return [[], []]
    max = f(0); r = [max]; i = [0]
    bound == 1 && return [r, i]
    for n in 1:bound
        if f(n) > max
            max = f(n)
            push!(r, max)
            push!(i, n)
        end
    end
    [SeqArray(r), SeqArray(i)]
end
doc"""
Return maxima relative to the predecessors and their positions of a sequence ``f``
as a pair of lists ``(r, i)`` where ``r`` contains the maxima and ``i`` the index where
they occur.
``f(0)`` is a maximum and ``f(i)`` is a maximum if ``f(j) < f(i)`` for all ``0 < j < i`` .
In the OEIS such values are often called 'record values'.
"""
function FindMaxima(len::Int, f::Function)
    len == 0 && return [[], []]
    max = f(0); r = [max]; i = [0]
    len == 1 && return [r, i]
    wm, n = 1, 1
    while wm < len
        if f(n) > max
            max = f(n)
            push!(r, max)
            push!(i, n)
            wm += 1
        end
        n += 1
    end
    [SeqArray(r), SeqArray(i)]
end
doc"""
Return the number of divisors of n-th highly composite numbers
which do not exceed the given bound.
"""
B002183(bound) = FindMaximaUpTo(bound, τ)[1]
doc"""
Return the number of divisors of n-th highly composite numbers.
"""
L002183(len) = FindMaxima(len, τ)[1]
doc"""
Return highly composite numbers which do not exceed the given bound.
"""
B002182(bound) = FindMaximaUpTo(bound, τ)[2]
doc"""
Return highly composite numbers.
"""
L002182(len) = FindMaxima(len, τ)[2]
doc"""
Return the record values of sigma(n) which do not exceed the given bound.
"""
B034885(bound) = FindMaximaUpTo(bound, σ)[1]
doc"""
Return the record values of sigma(n).
"""
L034885(len) = FindMaxima(len, σ)[1]
doc"""
Return highly abundant numbers which do not exceed the given bound.
"""
B002093(bound) = FindMaximaUpTo(bound, σ)[2]
doc"""
Return the primes minus 1 which do not exceed the given bound.
"""
B006093(bound) = FindMaximaUpTo(bound, ϕ)[1]
doc"""
Return the primes minus 1.
"""
L006093(len) = FindMaxima(len, ϕ)[1]
doc"""
The odd prime numbers together with 1 which do not exceed the given bound.
"""
B006005(bound) = FindMaximaUpTo(bound, ϕ)[2]
doc"""
The odd prime numbers together with 1.
"""
L006005(len) = FindMaxima(len, ϕ)[2]
# +++ NumberTheory.jl +++
import Nemo.zero
zero(::Nemo.fmpz) = fmpz(0)
doc"""
Return true if n is prime false otherwise.
"""
function IsPrime(n) Nemo.isprime(fmpz(n)) end
doc"""
Return factors of ``n``.
"""
Factors(n) = Nemo.factor(fmpz(n))
doc"""
Return the positive integers dividing ``n``.
"""
function Divisors(n)
    n == fmpz(0) && return fmpz[]
    IsPrime(n) && return [fmpz(1), n]
    d = [fmpz(1)]
    for (p, e) in Factors(n)
        c = [p^i for i in 0:e]
        d = d * c'
        d = reshape(d, length(d))
    end
    sort!(d)
end
doc"""
Return the prime numbers dividing ``n``.
"""
function PrimeDivisors(n)
    IsPrime(n) && return [fmpz(n)]
    f = Factors(n)
    sort!([p for (p, e) in f])
end
doc"""
Return the radical of ``n`` which is the product of the prime numbers dividing ``n``
(also called the squarefree kernel of ``n``).
"""
Radical(n) = ∏(PrimeDivisors(n))
doc"""
Return ``Ω(n)``,  the number of prime divisors of ``n`` counted with multiplicity.
Cf. A001222.
"""
function Ω(n)
    n == fmpz(0) && return 0
    IsPrime(n) && return fmpz(1)
    f = Factors(n)
    sum([e for (p, e) in f])
end
doc"""
Return the number of prime divisors of ``n`` counted with multiplicity.
"""
A001222(n) = Ω(n)
doc"""
Return the result of replacing each prime factor of n with 2.
"""
A061142(n) = 1 << Int(Ω(n))
doc"""
Return ``ω(n)``,  the number of distinct prime divisors of ``n``. Cf. A001221.
"""
ω(n) = fmpz(length(PrimeDivisors(n)))
doc"""
Return the number of distinct prime divisors of ``n``.
"""
A001221(n) = ω(n)
doc"""
Return the number of unitary divisors of ``n``, ``d`` such that ``d`` divides ``n``
and ``d ⊥ n/d``.
"""
A034444(n::Int) = 1 << Int(ω(n))
doc"""
Return ``τ(n)`` (a.k.a. ``σ_0(n)``), the number of divisors of ``n``. Cf. A000005.
"""
τ(n) = Nemo.sigma(fmpz(n), 0)
doc"""
Return the number of divisors of ``n``.
"""
A000005(n) = τ(n)
doc"""
Return ``σ(n)`` (a.k.a. ``σ_1(n)``), the sum of the divisors of ``n``. Cf. A000203.
"""
σ(n) = Nemo.sigma(fmpz(n), 1)
doc"""
Return the Euler totient ``ϕ(n)``, numbers which are ``≤ n`` and prime to ``n``.
"""
ϕ(n) = Nemo.eulerphi(fmpz(n))
doc"""
Return the number of integers ``≤ n`` and prime to ``n``.
"""
A000010(n) = ϕ(n)
doc"""
Return the value of the Möbius function ``μ(n)`` which is the sum of the
primitive n-th roots of unity.
"""
μ(n) = Nemo.moebiusmu(fmpz(n))
doc"""
Return the value of the Möbius function ``μ(n)`` which is the sum of the
primitive n-th roots of unity.
"""
A008683(n) = μ(n)
doc"""
Return the sum of the divisors of ``n``.
"""
A000203(n) = σ(n)
doc"""
Query if ``n`` is primeto to ``k``.
"""
IsPrimeTo(n, k) = Nemo.gcd(fmpz(n), fmpz(k)) == fmpz(1)
doc"""
Query if ``m`` is primeto to ``n``.
Knuth, Graham and Patashnik write in "Concrete Mathematics":
"Hear us, O mathematicians of the world! Let us not wait any longer!
We can make many formulas clearer by defining a new notation now!
Let us agree to write m ⊥ n, and to say "m is prime to n", if m and n are
relatively prime."
"""
⊥(m, n) = IsPrimeTo(m, n)
doc"""
Query if ``n`` is strong prime to ``k``.
"""
IsStrongPrimeTo(n, k) = IsPrimeTo(n, k) && k ∉ Divisors(n - 1)
doc"""
Query if ``n`` is strong prime to ``k``.
"""
⍊(n, k) = IsStrongPrimeTo(n, k)
doc"""
Return the number of integers ``≤ n`` which are strong primeto to ``n``.
"""
A181830(n) = n == 0 ? 0 : ϕ(n) - τ(n - 1)
doc"""
Is ``n`` a cyclic number? ``n`` such that there is just one group of order ``n``.
"""
IsCyclic(n) = n == 0 ? false : ⊥(n, ϕ(n))
doc"""
Return list of cyclic numbers of length len.
"""
L003277(len) = List(len, IsCyclic)
doc"""
Return the least absolute remainder mods uses the symmetric representation for
integers modulo m, i.e. remainders will be reduced to integers in the range
``[-``div``(|m| - 1, 2),``div``(|m|, 2)]``.
"""
function mods(b, a)
    b == 0 && return a
    h = a >> 1
    (q, r) = divrem(b, a)
    if h <  r  r -= a end
    if h < -r  r += a end
    r
end
doc"""
Is the integer ``n`` nonnegative?
"""
IsNonnegative(n) = n ≥ 0
doc"""
Is the integer ``n`` positive?
"""
IsPositive(n) = n > 0
doc"""
Is the integer ``n`` a square number?
"""
IsSquare(n) = Nemo.issquare(fmpz(n))
doc"""
Is the integer ``n`` a composite number?
"""
IsComposite(n) = 1 < Ω(n) && (n > 0)
doc"""
Is the integer ``n`` a squarefree number?
"""
IsSquareFree(n) = ω(n) == Ω(n) && (n > 0)
doc"""
Is the integer ``n`` a prime power?
"""
IsPrimePower(n) = ω(n) == 1
doc"""
Is the integer ``n`` a power of primes?
"""
IsPowerOfPrimes(n) = (n == 1) || (ω(n) == 1)
doc"""
Is the integer ``n`` a perfect powers?
"""
IsPerfectPower(n) = ω(n) == 1 && Ω(n) ≠ 1
doc"""
Return `true` if b is divisible by a, otherwise return `false`.
"""
Divides(a, b) = a ≠ 0 && rem(fmpz(b), fmpz(a)) == fmpz(0)
doc"""
Is n divisble by 2?
"""
IsEven(n) = Base.iseven(n)
doc"""
Is n indivisble by 2?
"""
IsOdd(n) = Base.isodd(n)
doc"""
Return the primorial of n, the product of the primes ≤ n.
"""
A034386(n) = Nemo.primorial(n)
doc"""
Return a list of the first n primes.
"""
PrimeList(len::Int) = SeqArray(len, IsPrime)
doc"""
Return the product of first n primes.
"""
A002110(n) = ∏(PrimeList(n))
# +++ OEISUtils.jl +++
ROOTDIR = Pkg.dir("MathIntSeq")
datadir = joinpath(ROOTDIR, "data")
srcdir = joinpath(ROOTDIR, "src")
moddir = joinpath(srcdir, "modules")
doc"""
Returns the path where the oeis data is expected.
"""
oeis_path() = joinpath(datadir, "stripped")
doc"""
Indicates if the local copy of the OEIS data (the so-called
'stripped' file) is installed (in MathIntSeq/data).
"""
oeis_isinstalled() = isfile(oeis_path())
doc"""
Indicates if the local copy of the OEIS data (the so-called
'stripped' file) is not installed and warns.
"""
function oeis_notinstalled()
    if !oeis_isinstalled()
        warn("OEIS data not installed! Download stripped.gz from oeis.org,")
        warn("expand it and put it in the directory MathIntSeq/data.")
        return true
    end
    return false
end
doc"""
Write a so-called b-file for submission to the OEIS. The file is saved in the
'data' directory.
"""
function oeis_writebfile(anum, fun, offset::Int, len::Int)
    if !ismatch(r"^A[0-9]{6}$", anum)
        warn("Not a valid A-number!")
        return
    end
    filename = joinpath(datadir, "b" * anum[2:end] * ".txt")
    info("Writing " * anum * " to " * filename)
    f = open(filename, "w")
    for n in offset:(offset + len)
        println(f, n, " ", fun(n))
    end
    close(f)
end
function oeis_writebfile(anum, list)
    if !ismatch(r"^A[0-9]{6}$", anum)
        warn("Not a valid A-number!")
        return
    end
    filename = joinpath(datadir, "b" * anum[2:end] * ".txt")
    info("Writing " * anum * " to " * filename)
    n = 1
    f = open(filename, "w")
    for l in list
        println(f, n, " ", list[n])
        n += 1
    end
    close(f)
end
doc"""
Make sure that the length of the data section of an OEIS entry does not exceed
260 characters.
"""
function oeis_trimdata(fun, offset::Int)
    len = n = 0
    S = ""
    while true
        st = string(fun(offset + n))
        len += length(st)
        len > 260 && break
        S *= st * ", "
        len += 2
        n += 1
    end
    println(n, " terms")
end
doc"""
Download the sequence with A-number 'anum' from the OEIS to a file in json format.
The file is saved in the 'data' directory.
"""
function oeis_remote(anum)
    if !ismatch(r"^A[0-9]{6}$", anum)
        warn("Not a valid A-number!")
        return
    end
    filename = joinpath(datadir, anum * ".json")
    url = HTTP.URI("http://oeis.org/search?q=id:" * anum * "&fmt=json")
    tries = 3
    r = nothing
    for i = 1:tries
        try
            r = HTTP.get(url; readtimeout=.5)
            HTTP.status(r) == 200 && break
            HTTP.status(r) == 302 && break # redirection
        catch e
        end
        sleep(2)
    end
    if r ≠ nothing && HTTP.status(r) == 200
        open(filename, "w") do f
            write(f, HTTP.body(r))
        end
        info("Dowloaded " * basename(filename) * " to " * datadir)
    else
        if r == nothing
            warn("Could not download $url, connection timed out.\n")
        else
            warn("Could not download $url\nStatus: $(HTTP.status(r))")
        end
    end
end
doc"""
Get the sequence with A-number 'anum' from a local copy of the expanded
'stripped.gz' file which can be downloaded from the OEIS. 'bound' is an upper
bound for the number of terms returned. The 'stripped' file is assumed to be in
the 'MathIntSeq/data' directory .
"""
function oeis_local(anum::String, bound::Int)
    if !ismatch(r"^A[0-9]{6}$", anum)
        warn(anum * " is not a valid A-number!")
        return []
    end
    oeis_notinstalled() && return []
    A = Array{String}
    data = open(oeis_path())
    for ln in eachline(data)
        if startswith(ln, anum)
            A = split(chop(chomp(ln)), ","; limit=bound + 2)
            break;
        end
    end
    close(data)
    SeqArray([convert(fmpz, parse(BigInt, n)) for n in A[2:min(bound + 1, end)]])
end
doc"""
Search for a sequence in the local OEIS database ('MathIntSeq/data/stripped').
Input the sequence as a comma separated string. If restart = true the search
is redone in the case that no match was found with the first term removed
from the search string. Prints the matches.
"""
function oeis_search(seq::String, restart::Bool)
    oeis_notinstalled() && return []
    found = false
    seq = replace(seq, ' ', "")
    println("Searching for:")
    println(seq)
    data = open(oeis_path())
    for ln in eachline(data)
        index = searchindex(ln, seq)
        index == 0 && continue
        println("Starts at ", index - 10, " ", ln)
        found = true
    end
    close(data)
    if !found && restart
        ind = search(seq, ',')
        if (ind > 0) && (length(seq) > ind)
            seq = seq[ind + 1:end]
            println("Restarting omitting the first term.")
            oeis_search(seq, false)
        end
    end
end
# +++ OrthoPolynomials.jl +++
doc"""
By the theorem of Favard an orthogonal polynomial systems  ``p_{n}(x)`` is a
sequence of real polynomials with deg``(p_{n}(x)) = n`` for all ``n`` if and only if
``$ p_{n+1}(x) = (x - s_n)p_n(x) - t_n p_{n-1}(x) $``
with ``p_{0}(x)=1`` for some pair of seq's ``s_k`` and ``t_k``. Return the
coefficients of the polynomials as a triangular array with dim rows.
"""
function OrthoPoly(dim::Int, s::Function, t::Function)
    T = SeqTriangle(dim)
    T[0] = 1
    lo = hi = 0
    for row in 2:dim
        olo = lo
        lo = hi + 1
        hi += row
        j = lo - row
        for k in lo:hi - 1
            T[k] = (j < olo ? 0 : T[j]) + s(k - 1 - lo) * T[j + 1] + (j + 2 < lo ? t(k - lo) * T[j + 2] : 0)
            j += 1
        end
        T[hi] = 1
    end
    T
end
doc"""
Return the inverse of the coefficients of the orthogonal polynomials generated
by ``s`` and ``t`` as a triangular array with dim rows.
"""
function InvOrthoPoly(dim::Int, s::Function, t::Function)
    dim ≤ 0 && return fmpz[]
    T = zeros(ZZ, dim, dim)
    for n in 1:dim T[n, n] = 1 end
    for n in 1:dim - 1
        for k in 1:n + 1
            T[n + 1, k] = (k > 1 ? T[n,k - 1] : 0) - s(n - 1) * T[n,k] - (n > 1 ? t(n - 1) * T[n - 1,k] : 0)
        end
    end
    SeqArray(□toΔ(T))
end
doc"""
Return the Catalan triangle (with 0's) read by rows.
"""
T053121(dim::Int) = OrthoPoly(dim, n -> 0, n -> 1)
doc"""
Return the coefficients of some orthogonal polynomials related to set partitions
without singletons (A000296).
"""
T216916(dim::Int) = OrthoPoly(dim, n -> n + 2, n -> n + 2)
doc"""
Return the triangle ``T(n,k)`` of tangent numbers, coefficient of ``x^n/n!``
in the expansion of ``(\tan x)^k/k!``.
"""
T059419(dim::Int) = OrthoPoly(dim, n -> 0, n -> (n + 1) * (n + 2))
doc"""
Return the expansion of ``\exp(\tan(x))``.
"""
L006229(len::Int) = RowSums(T059419(len))
doc"""
Return the first len integers defined as ``a(n) = n! [x^n] \exp(2 \exp(x)-x-2)``.
"""
L217924(len::Int) = RowSums(T217537(len))
doc"""
Return the coefficients of some orthogonal polynomials related to indecomposable
set partitions without singletons (A098742).
"""
T217537(dim::Int) = OrthoPoly(dim, n -> n + 1, n -> n + 1)
doc"""
Return the Motzkin triangle read in row reverse order.
"""
T064189(dim::Int) = OrthoPoly(dim, n -> 1, n -> 1)
doc"""
Return the Motzkin triangle.
"""
T026300(dim::Int) = RowReverse(OrthoPoly(dim, n -> 1, n -> 1))
doc"""
Return the number of directed animals of size n as an array of length len.
"""
L005773(len::Int) = RowSums(T064189(len))
doc"""
Return the coefficients of ``x^n`` in the expansion of ``((-1-x+√(1+2x+5x^2))/2)^k``
as a triangle with dim rows.
"""
T202327(dim::Int) = OrthoPoly(dim, n -> -1, n -> -1)
doc"""
Return the sequence with generating function satisfying
``x = (A(x)+(A(x))^2)/(1-A(x)-(A(x))^2)``.
"""
L108624(len::Int) = RowSums(T202327(len))
doc"""
Return the triangle T(n, k) = ``\binom{n}{k}`` involutions``(n - k)``.
"""
T111062(dim::Int) = OrthoPoly(dim, n -> 1, n -> n + 1)
doc"""
Return the number of self-inverse partial permutations.
"""
L005425(len::Int) = RowSums(T111062(len))
doc"""
Return the coefficients of the modified Hermite polynomials.
"""
T099174(dim::Int) = OrthoPoly(dim, n -> 0, n -> n + 1)
doc"""
Return the number of involutions.
"""
L000085(len::Int) = RowSums(T099174(len))
doc"""
Return the coefficients of unitary Hermite polynomials He``_n(x)``.
"""
T066325(dim::Int) = InvOrthoPoly(dim, n -> 0, n -> n)
doc"""
Return the sequence defined by ``a(n) = n! [x^n] \exp(-x-(x^2)/2)``.
"""
L001464(len::Int) = RowSums(T066325(len), true)
doc"""
Return the triangle of tanh numbers.
"""
T111593(dim::Int) = OrthoPoly(dim, n -> 0, n -> -n * (n + 1))
doc"""
Return the sequence defined by ``A(n) = n! [x^n] \exp{\tan{x}}`` as an array
of length len.
"""
L003723(len::Int) = RowSums(T111593(len))
doc"""
Return the coefficients of Chebyshev's U``(n, x/2)`` polynomials.
"""
T049310(dim::Int) = InvOrthoPoly(dim, n -> 0, n -> 1)
doc"""
Return the coefficients of the Charlier polynomials with parameter ``a=1``.
"""
T137338(dim::Int) = InvOrthoPoly(dim, n -> n + 1, n -> n + 1)
doc"""
Return the inverse of the Motzkin triangle (A064189).
"""
T104562(dim::Int) = InvOrthoPoly(dim, n -> 1, n -> 1)
doc"""
Return the skew Fibonacci-Pascal triangle with dim rows.
"""
T037027(dim::Int) = InvOrthoPoly(dim, n -> -1, n -> -1)
doc"""
Return the arctangent numbers (expansion of arctan``(x)^n/n!``).
"""
T049218(dim::Int) = InvOrthoPoly(dim, n -> 0, n -> n * (n + 1))
doc"""
Return the coefficients of Hermite polynomials ``H(n, (x-1)/√(2))/(√(2))^n``.
"""
T159834(dim::Int) = InvOrthoPoly(dim, n -> 1, n -> n)
doc"""
Return the coefficients of a variant of the Hermite polynomials.
"""
T137286(dim::Int) = InvOrthoPoly(dim, n -> 0, n -> n + 1)
doc"""
Return the coefficients of the Chebyshev-T polynomials.
"""
function T053120(len)
    T = SeqTriangle(len)
    R, x = PolynomialRing(ZZ, "x")
    m = 0
    for n in 0:len - 1
        f = chebyshev_t(n, x)
        for k in 0:n
            T[m] = coeff(f, k)
            m += 1
        end
    end
    T
end
doc"""
Return the coefficients of the Chebyshev-U polynomials.
"""
function T053117(len)
    T = SeqTriangle(len)
    R, x = PolynomialRing(ZZ, "x")
    m = 0
    for n in 0:len - 1
        f = chebyshev_u(n, x)
        for k in 0:n
            T[m] = coeff(f, k)
            m += 1
        end
    end
    T
end
# +++ Partitions.jl +++
doc"""
Generates the integer partitions of ``n`` in lexicographic order.
Ported from Wilf/Nijenhuis "Combinatorial Algorithms". Cf. A080577.
"""
function NEXPAR(N::Int)
    R = Dict{Int,Int}()
    M = Dict{Int,Int}()
    NLAST = 0
@label(L10)
    N == NLAST && @goto(L20)
    NLAST = N
@label(L30)
    S = N
    D = 0
@label(L50)
    D = D + 1
    R[D] = S
    M[D] = 1
@label(L40)
    MTC = M[D] ≠ N
    PRINTPAR(D, R, M)
    ! MTC && return
    @goto(L10)
@label(L20)
    ! MTC && @goto(L30)
    SUM = 1
    R[D] > 1 && @goto(L60)
    SUM = M[D] + 1
    D = D - 1
@label(L60)
    F = R[D] - 1
    M[D] == 1 && @goto(L70)
    M[D] = M[D] - 1
    D = D + 1
@label(L70)
    R[D] = F
    M[D] = 1 + div(SUM, F)
    S = SUM % F
    S == 0 && @goto(L40)
    @goto(L50)
end
doc"""
Prints the partitions given in the format used in function NEXPAR.
"""
function PRINTPAR(D::Int, R::Dict{Int,Int}, M::Dict{Int,Int})
    F = Int64[]
    for i in 1:D
        append!(F, [R[i] for j in 1:M[i]])
    end
    println(F)
end
doc"""
Generates the integer partitions of ``n`` in lexicographic order.
"""
Partition(n::Int) = NEXPAR(n)
doc"""
Generates the integer partitions of ``n`` in lexicographic order.
"""
A080577(n::Int) = NEXPAR(n)
# +++ PrimeSieve.jl +++
const wheel         = [4,  2,  4,  2,  4,  6,  2,  6]
const wheel_primes  = [7, 11, 13, 17, 19, 23, 29, 31]
const wheel_indices = [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 7, 7]
@inline function wheel_index(n)
    d, r = divrem(n - 1, 30)
    return 8d + wheel_indices[r + 2]
end
@inline function wheel_prime(n)
    d, r = (n - 1) >>> 3, (n - 1) & 7
    return 30d + wheel_primes[r + 1]
end
function mask(limit::Int)
    limit < 7 && throw(ArgumentError("The condition limit ≥ 7 must be met."))
    n = wheel_index(limit)
    m = wheel_prime(n)
    sieve = ones(Bool, n)
    @inbounds for i = 1:wheel_index(isqrt(limit))
        if sieve[i]
            p = wheel_prime(i)
            q = p^2
            j = (i - 1) & 7 + 1
            while q ≤ m
                sieve[wheel_index(q)] = false
                q += wheel[j] * p
                j = j & 7 + 1
            end
        end
    end
    return sieve
end
function mask(lo::Int, hi::Int)
    7 ≤ lo ≤ hi || throw(ArgumentError("The condition 7 ≤ lo ≤ hi must be met."))
    lo == 7 && return mask(hi)
    wlo, whi = wheel_index(lo - 1), wheel_index(hi)
    m = wheel_prime(whi)
    sieve = ones(Bool, whi - wlo)
    hi < 49 && return sieve
    small_sieve = mask(isqrt(hi))
    @inbounds for i = 1:length(small_sieve)  # don't use eachindex here
        if small_sieve[i]
            p = wheel_prime(i)
            j = wheel_index(2 * div(lo - p - 1, 2p) + 1)
            q = p * wheel_prime(j + 1)
            j = j & 7 + 1
            while q ≤ m
                sieve[wheel_index(q) - wlo] = false
                q += wheel[j] * p
                j = j & 7 + 1
            end
        end
    end
    return sieve
end
doc"""
Returns a prime sieve, as a `BitArray`, of the positive integers (from `lo`, if
specified) up to `hi`. Useful when working with either primes or composite numbers.
"""
function primesmask(lo::Int, hi::Int)
    0 < lo ≤ hi || throw(ArgumentError("The condition 0 < lo ≤ hi must be met."))
    sieve = falses(hi - lo + 1)
    lo ≤ 2 ≤ hi && (sieve[3 - lo] = true)
    lo ≤ 3 ≤ hi && (sieve[4 - lo] = true)
    lo ≤ 5 ≤ hi && (sieve[6 - lo] = true)
    hi < 7 && return sieve
    wheel_sieve = mask(max(7, lo), hi)
    lsi = lo - 1
    lwi = wheel_index(lsi)
    @inbounds for i = 1:length(wheel_sieve)   # don't use eachindex here
        sieve[wheel_prime(i + lwi) - lsi] = wheel_sieve[i]
    end
    return sieve
end
primesmask(lo::T, hi::T) where {T <: Integer} = lo ≤ hi ≤ typemax(Int) ? primesmask(Int(lo), Int(hi)) :
    throw(ArgumentError("Both endpoints of the interval to sieve must be ≤ $(typemax(Int)), got $lo and $hi."))
primesmask(limit::Int) = primesmask(1, limit)
primesmask(n::Integer) = n ≤ typemax(Int) ? primesmask(Int(n)) :
    throw(ArgumentError("Requested number of primes must be ≤ $(typemax(Int)), got $n."))
doc"""
Returns a collection of the prime numbers (from `lo`, if specified) up to `hi`.
"""
function Primes(lo::Int, hi::Int)
    lo ≤ hi || throw(ArgumentError("The condition lo ≤ hi must be met."))
    list = Int[]
    lo ≤ 2 ≤ hi && push!(list, 2)
    lo ≤ 3 ≤ hi && push!(list, 3)
    lo ≤ 5 ≤ hi && push!(list, 5)
    hi < 7 && return list
    lo = max(2, lo)
    sizehint!(list, 5 + floor(Int, hi / (log(hi) - 1.12) - lo / (log(lo) - 1.12 * (lo > 7))))
    sieve = mask(max(7, lo), hi)
    lwi = wheel_index(lo - 1)
    @inbounds for i = 1:length(sieve)
        sieve[i] && push!(list, wheel_prime(i + lwi))
    end
    return list
end
Primes(n::Int) = Primes(1, n)
# +++ Products.jl +++
doc"""
If ``a ≤ b`` then return the product of ``i`` in ``a:b`` else return ``1``.
"""
function ∏(a::Int, b::Int)
    n = b - a
    if n < 24
        p = ZZ(1)
        for k in a:b
            p *= k
        end
        return p
    end
    m = div(a + b, 2)
    ∏(a, m) * ∏(m + 1, b)
end
doc"""
If ``a ≤ b`` then return the product of ``i`` in ``a:b`` else return ``1``.
"""
Product(a::Int, b::Int) = ∏(a, b)
doc"""
Return the accumulated product of an array.
"""
function ∏(A)
    function prod(a::Int, b::Int)
        n = b - a
        if n < 24
            p = ZZ(1)
            for k in a:b
                p *= A[k]
            end
            return p
        end
        m = div(a + b, 2)
        prod(a, m) * prod(m + 1, b)
    end
    A == [] && return 1
    if IsSeqArray(A)
        prod(0, length(linearindices(A))-1)
    else
        prod(1, length(A))
    end
end
doc"""
Return the accumulated product of an array.
"""
Product(A) = ∏(A)
doc"""
Return ``\frac{n!} {⌊n/2⌋!}``.
"""
A081125(n::Int) = ∏(div(n, 2) + 1, n)
doc"""
Return the rising factorial which is the product of ``i`` in ``n:(n + k - 1)``.
"""
RisingFactorial(n::Int, k::Int) = ∏(n, n + k - 1)
doc"""
Return the rising factorial which is the product of ``i`` in ``n:(n + k - 1)``.
A convenient infix syntax for the rising factorial is n ↑ k.
"""
↑(n, k) = RisingFactorial(n, k)
doc"""
Return the rising factorial i.e. the product of ``i`` in ``n:(n + k - 1)``.
"""
A265609(n::Int, k::Int) = RisingFactorial(n, k)
doc"""
Return the falling factorial which is the product of ``i`` in ``(n - k + 1):n``.
"""
FallingFactorial(n::Int, k::Int) = ∏(n - k + 1, n)
doc"""
Return the falling factorial which is the product of ``i`` in ``(n - k + 1):n``.
A convenient infix syntax for the falling factorial is n ↓ k.
"""
↓(n, k) = FallingFactorial(n, k)
doc"""
Return the number of permutations of n letters, ``n! = ∏(1, n)``,
the factorial of ``n``.
"""
F!(n::Int) = Nemo.fac(n)
doc"""
Return the factorial numbers.
"""
A000142(n::Int) = Nemo.fac(n)
doc"""
Return the central rising factorial ``(n+1) ↑ (n+1) = (2n+1)! / n!``.
"""
A000407(n::Int) = (n + 1) ↑ (n + 1)
doc"""
Return the restricted rising factorial which is zero for ``n < 0`` or ``k > n``.
"""
A124320(n::Int, k::Int) = (n < 0 || k > n) ? 0 : ∏(n, n + k - 1)
doc"""
Return the multi-factorial which is the function ``n → ∏(a + b, a(n-1) + b)``
"""
MultiFactorial(a::Int, b::Int) = n -> ∏([a * k + b for k in 0:(n - 1)])
doc"""
Return the double factorial of odd numbers, ``1×3×5×...×(2n-1) = (2n-1)!!``.
"""
A001147(n::Int) = MultiFactorial(2, 1)(n)
doc"""
Return the double factorial of even numbers: ``2^n n! = (2n)!!``.
"""
A000165(n::Int) = MultiFactorial(2, 2)(n)
doc"""
Return the triple factorial numbers with shift 1, ``3^n n! = (3n)!!!``.
"""
A007559(n::Int) = MultiFactorial(3, 1)(n)
doc"""
Return the triple factorial numbers with shift 2.
"""
A008544(n::Int) = MultiFactorial(3, 2)(n)
doc"""
Return the triple factorial numbers with shift 3.
"""
A032031(n::Int) = MultiFactorial(3, 3)(n)
doc"""
Return the quadruple factorial numbers with shift 1.
"""
A007696(n::Int) = MultiFactorial(4, 1)(n)
doc"""
Return the quadruple factorial numbers with shift 2, ``(2n)!/n!``.
"""
A001813(n::Int) = MultiFactorial(4, 2)(n) # = ∏(n + 1, 2n)
doc"""
Return the quadruple factorial numbers with shift 3.
"""
A008545(n::Int) = MultiFactorial(4, 3)(n)
doc"""
Return the quadruple factorial numbers ``4^n n!``.
"""
A047053(n::Int) = MultiFactorial(4, 4)(n)
# +++ Recursive2.jl +++
doc"""
Computes recursive sequences of the form
``a(n) = f(n) a(n-1) + g(n) a(n-2)`` with given initial values ``a(0)`` and
``a(1)`` (with defaults 1), ``f(n)`` and ``g(n)`` not zero and at least one
of the functions ``f(n)``, ``g(n)`` is _not_ constant.
"""
function Recurrence2(len::Int, f::Function, g::Function, a1=1, a2=1)
    len ≤ 0 && return fmpz[]
    A = Array{fmpz}(len)
    for n in 0:len - 1
        if n == 0
            A[1] = a1
        elseif n == 1
            A[2] = a2
        else
            A[n + 1] = f(n) * A[n] + g(n) * A[n - 1]
        end
    end
    SeqArray(A)
end
doc"""
Return an array of length len of the Hankel transform of the Bessel numbers
starting at n = 1. (David Callan)
"""
L058797(len::Int) = Recurrence2(len, n -> n, n -> -1)
doc"""
Return an array of length len of the continuant transform of ``1, 2, 3, 4, 5, …``.
"""
L001040(len::Int) = Recurrence2(len, n -> n, n -> 1)
doc"""
Return the number of palindromic compositions of ``n`` into odd parts. (Emeric Deutsch)
"""
L053602(len::Int) = Recurrence2(len, n -> 1, n -> (-1)^n)
doc"""
Return the number of permutations in the symmetric group ``S_n`` that have
a fixed point.
"""
L002467(len::Int) = Recurrence2(len, n -> n, n -> n)
doc"""
Return an array of length len of the continuant transform of squares ``1, 4, 9, …``.
"""
L036246(len::Int) = Recurrence2(len, n -> n^2, n -> 1)
doc"""
Return an array of length len of the sequence with generating function
``2 ((√(2) + x)^2/(2 - x^2))^{\frac{1}{√(2)}} /(2 - x^2)``. (Vaclav Kotesovec)
"""
L166474(len::Int) = Recurrence2(len, n -> 1, n -> div(n^2 - n, 2))
doc"""
Return an array of length len of the sequence with exponential generating function
``2 π(I`` Bessel``Y(3, 2I)`` Bessel``I(2, 2 √(1-x)) +``
Bessel``I(3, 2)`` Bessel``Y(2, 2 I √(1-x)))/(1-x)``. (Wolfdieter Lang)
"""
L058279(len::Int) = Recurrence2(len, n -> n + 1, n -> 1)
doc"""
``a(n) = n(n-1)a(n-1)/2 + a(n-2)``.
"""
L001046(len::Int) = Recurrence2(len, n -> div(n^2 - n, 2), n -> 1)
doc"""
Return the first len terms defined by
``a(n) = n! [x^n] (1 - √(Pi/2) \exp(-((x - 1)^2) / 2) (x - 1)
(erfi((x - 1) / √(2)) + erfi(1 / √(2))))``. For 'erfi' see MathWorld.
"""
L286032(len::Int) = Recurrence2(len, n -> 1, n -> -n)
doc"""
Return the number of n-permutations that have a cycle with length greater
than ``n/2``. (Geoffrey Critzer)
"""
L024167(len::Int) = Recurrence2(len, n -> 1, n -> n^2)
doc"""
Return the number of involutions such that every 2-cycle contains one odd and
one even element. (Alois P. Heinz)
"""
L056953(len::Int) = Recurrence2(len, n -> 1, n -> div(n, 2))
doc"""
Return the number of permutations in the symmetric group ``S_n`` that have odd order.
"""
L000246(len::Int) = Recurrence2(len, n -> 1, n -> (n - 1) * (n - 2))
doc"""
Return ``n!`` Fibonacci``(n+1)``.
"""
L005442(len::Int) = Recurrence2(len, n -> n, n -> n^2 - n)
# +++ SelfConvolutive.jl +++
Convolution(A, n) = sum(A[j] * A[n - j] for j in 0:n)
doc"""
An exactly solvable self-convolutive recurrence studied by R. J. Martin and
M. J. Kearney.
"""
function SelfConvRec(len, a, b, c)
    A = SeqArray(len)
    len == 0 && return A
    A[0] = 1
    for n in 1:len - 1
        A[n] = (a * (n + 1) + b) * A[n - 1] + c * Convolution(A, n - 1)
    end
    A
end
doc"""
Return the number of indecomposable perfect matchings on ``[2n]``. (David Callan)
"""
L000698(len::Int) = SelfConvRec(len, 2, -3, 1)
doc"""
Return the order of alternating group ``A_n``, or number of even permutations
of ``n`` letters.
"""
L001710(len::Int) = SelfConvRec(len, 1, 1, 0)
doc"""
Return the number of connected permutations of ``[1..n]``. Also called
indecomposable permutations.
"""
L003319(len::Int) = SelfConvRec(len, 1, -2, 1)
doc"""
Return the number of non-vanishing Feynman diagrams of order ``2n`` for the
electron or the photon propagators in quantum electrodynamics.
"""
L005411(len::Int) = SelfConvRec(len, 2, -4, 1)
doc"""
Return the number of non-vanishing Feynman diagrams of order ``2n`` for the
vacuum polarization in quantum electrodynamics.
"""
L005412(len::Int) = SelfConvRec(len, 2, -2, 1)
doc"""
Counting some sets of permutations.
"""
L006012(len::Int) = SelfConvRec(len, -1, 2, 2)
doc"""
Return the large Schröder numbers.
"""
L006318(len::Int) = SelfConvRec(len, 0, 1, 1)
doc"""
Return the number of planar rooted trees with ``n`` nodes and tricolored end nodes.
"""
L047891(len::Int) = SelfConvRec(len, 0, 2, 1)
doc"""
Return the number of rooted unlabeled connected triangular maps on a compact
closed oriented surface with ``2n`` faces.
"""
L062980(len::Int) = SelfConvRec(len, 6, -8, 1)
doc"""
Return the number of lattice paths from ``(0,0)`` to ``(n+1,n+1)`` that consist
of steps ``(i,0)`` and ``(0,j)`` with ``i,j≥1`` and stay strictly below the
diagonal line ``y=x`` except at the endpoints.
"""
L082298(len::Int) = SelfConvRec(len, 0, 3, 1)
doc"""
Return the number of Schröder paths of semilength n in which the (2,0)-steps
come in 4 colors. (Emeric Deutsch)
"""
L082301(len::Int) = SelfConvRec(len, 0, 4, 1)
doc"""
Return the coefficients in the expansion of ``(1-5x-√(25x^2-14x+1))/(2x)``.
"""
L082302(len::Int) = SelfConvRec(len, 0, 5, 1)
doc"""
Return the coefficients in the expansion of ``(1+2x-√(1+4x^2))/(2x)``.
"""
L105523(len::Int) = SelfConvRec(len, 0, -2, 1)
doc"""
A transform the of triple factorial numbers.
"""
L107716(len::Int) = SelfConvRec(len, 3, -4, 1)
doc"""
A convolutory inverse of the factorial sequence.
"""
L111529(len::Int) = SelfConvRec(len, 1, -3, 2)
doc"""
A convolutory inverse of the factorial sequence.
"""
L111530(len::Int) = SelfConvRec(len, 1, -4, 3)
doc"""
A convolutory inverse of the factorial sequence.
"""
L111531(len::Int) = SelfConvRec(len, 1, -5, 4)
doc"""
A convolutory inverse of the factorial sequence.
"""
L111532(len::Int) = SelfConvRec(len, 1, -6, 5)
doc"""
A convolutory inverse of the factorial sequence.
"""
L111533(len::Int) = SelfConvRec(len, 1, -7, 6)
doc"""
Return the expansion of ``(1-x)/(1 - 2x + 2x^2)``.
"""
L146559(len::Int) = SelfConvRec(len, 1, 1, -2)
doc"""
Return half the number of Feynman diagrams of order ``2(n+1)``, for the electron
self-energy in quantum electrodynamics.
"""
L167872(len::Int) = SelfConvRec(len, 2, -3, 2)
# +++ SeqBase.jl +++
ZeroRange(n) = 0:n - 1
doc"""
Return the size of a SeqArray.
"""
SeqSize(A) = Base.length(linearindices(A))
doc"""
Return the range of a SeqArray.
"""
SeqRange(A) = ZeroRange(SeqSize(A))
doc"""
Return a SeqArray of size n. (Preset with zeros.)
"""
SeqArray(n::Int) = n ≤ 0 ? fmpz[] : OffsetArray(fill(fmpz(0), n), ZeroRange(n))
doc"""
Return a SeqArray of size n. (Preset with zeros.)
"""
function SeqArray(len::Int, offset::Int)
    offset == 0 && return SeqArray(len)
    (offset < 0 || offset >= len) && error("Argument error offset: $(offset).")
    A = OffsetArray(Array{fmpz}(len), ZeroRange(len))
    for i in offset:len - 1 A[i] = 0 end
    A
end
doc"""
Return a SeqArray of size n preset with m.
"""
FillArray(m, n::Int) = OffsetArray(fill(fmpz(m), n), ZeroRange(n))
const SeqType = OffsetArrays.OffsetArray{Nemo.fmpz,1,Array{Nemo.fmpz,1}}
doc"""
Return true if A is a SeqArray, otherwise false.
"""
function IsSeqArray(A)
    typeof(A) == SeqType
end
doc"""
Throws an ArgumentError if A is not a SeqArray.
"""
function AssertSeqArray(A)
    if !IsSeqArray(A)
        throw(ArgumentError(string(A) * " is not a SeqArray."))
    end
end
doc"""
Convert a tuple or a 1-based array A into a SeqArray.
"""
function SeqArray(A)
    IsSeqArray(A) && return A
    n = length(A)
    R = OffsetArray(Array{fmpz}(n), ZeroRange(n))
    for k in SeqRange(R) R[k] = fmpz(A[k + 1]) end
    R
end
doc"""
Return a iterator listing the values satisfying the predicate isA for arguments
in ``0 ≤ n ≤ bound .``
"""
function IterateUpTo(bound, isA)
    (i for i in 0:bound if isA(i))
end
doc"""
Return a SeqArray listing the values satisfying the predicate isA for arguments
``0 ≤ x ≤ `` bound.
julia> FindUpTo(7, IsPrime)
[2, 3, 5, 7]
"""
function FindUpTo(bound, isA)
    bound < 0 && return fmpz[]
    SeqArray(filter(isA, 0:bound))
end
doc"""
Given a boolean predicate 'isA' the function returns integers ``n`` which are
isA for ``a < n ≤ b``. This supports convenient partitioning of intervals.
julia> FindInInterval(7, 13, IsPrime)
[11, 13]
FindInInterval(13, 23, IsPrime)
[17, 19, 23]
"""
function FindInInterval(a, b, isA::Function)
    b < 0 && return fmpz[]
    SeqArray(filter(isA, a + 1:b))
end
doc"""
Return a list of length len of integers ``≥ 0`` which are isA.
julia> List(7, IsPrime)
[2, 3, 5, 7, 11, 13, 17]
"""
function List(len, isA::Function)
    len ≤ 0 && return fmpz[]
    j, c = Int(0), Int(0)
    A = OffsetArray(Array{fmpz}(len), ZeroRange(len))
    while c < len
        if isA(j)
            A[c] = fmpz(j)
            c += 1
        end
        j += 1
    end
    A
end
hasparameters(f) = 0 < maximum((length(m.sig.parameters) for m in methods(f))...)
returnsboolean(f) = first((methods(f)...)).specializations.func.rettype == Bool
doc"""
Return a SeqArray of size n filled by the function f. If f is a boolean indicator
then List(n, f) is returned otherswise A[i] = f(i).
"""
function SeqArray(n::Int, f)
    n ≤ 0 && return fmpz[]
    if returnsboolean(f)
        return List(n, f)
    end
    if hasparameters(f)
        A = OffsetArray(Array{fmpz}(n), ZeroRange(n))
        for i in SeqRange(A) A[i] = f(i) end
        return A
    end
    error("Function not supported by this constructor!")
end
doc"""
Return a SeqArray of size n filled by the next n values taken from the channel.
"""
function SeqArray(n::Int, c::Channel)
    n ≤ 0 && return fmpz[]
    A = OffsetArray(Array{fmpz}(n), ZeroRange(n))
    for i in SeqRange(A) A[i] = take!(c) end
    A
end
doc"""
Return the n-th triangular number.
"""
TriangularNumber(n) = div(n * (n + 1), 2)
doc"""
Is n a triangular number?
"""
IsTriangular(n) = n == TriangularNumber(isqrt(2n))
doc"""
Return the sqrt of 2n or throw an ArgumentError if n is not a triangular number.
"""
function AssertTriangular(n)
    dim = isqrt(2n)
    n ≠ TriangularNumber(dim) && throw(ArgumentError("This is not a triangular array!"))
    dim
end
doc"""
Return a trianguler array with n rows which is (0,0)-based.
"""
SeqTriangle(n::Int) = SeqArray(TriangularNumber(n))
doc"""
Convert a tuple or a 1-based array A into a SeqTriangle provided its length
is triangular.
"""
function SeqTriangle(A)
    if IsSeqArray(A)
        n = SeqSize(A)
        AssertTriangular(n)
        return A
    end
    n = length(A)
    AssertTriangular(n)
    R = OffsetArray(Array{fmpz}(n), ZeroRange(n))
    for k in SeqRange(R) R[k] = fmpz(A[k + 1]) end
    R
end
doc"""
Return a SeqTriangle with r rows generated by a function f(n::Int, k::Int).
"""
function SeqTriangle(r::Int, f::Function)
    SeqTriangle([f(k, j) for k in 0:r - 1 for j in 0:k])
end
doc"""
Return a (1,1)-based quadratic matrix of dimension dim preset with 0.
"""
SeqMatrix(dim) = dim ≤ 0 ? (return fmpz[]) : fill(fmpz(0), dim, dim)
doc"""
Print the SeqArray in the format 'n ↦ A[n]' for n in the range first:last.
"""
SeqShow(A, first::Int, last::Int) = SeqShow(A, first:last)
doc"""
Print the SeqArray in the format 'n ↦ A[n]'.
"""
SeqShow(A) = SeqShow(A, SeqRange(A))
function SeqShow(A, R)
    for i in R
        if isassigned(A, i)
            println(i, " ↦ ", A[i])
        else
            println(i, " ↦ ", "undef")
        end
    end
end
function print_without_type(io, v::AbstractVector)
    print(io, "[")
    for (i, el) in enumerate(v)
        i > 1 && print(io, ", ")
        print(io, el)
    end
    println(io, "]")
end
doc"""
Print the array without typeinfo.
"""
Println(v::AbstractVector) = print_without_type(IOContext(STDOUT; :compact => true), v)
doc"""
Print the SeqArray with or without typeinfo.
"""
function SeqPrint(v::AbstractVector, typeinfo = false)
    typeinfo ? println(v) : Println(v)
end
doc"""
Return row n of a lower triangular matrix (0 ≤ n).
"""
function Row(T, n::Int)
    AssertSeqArray(T)
    s = SeqSize(T)
    (s == 0 || n < 0) && return
    AssertTriangular(s)
    t = TriangularNumber(n + 1)
    s < t && error("This row is not in the matrix.")
    SeqArray([T[k] for k in t - n - 1:t - 1])
end
doc"""
Display a lower triangular matrix.
julia> Show(T225478(6))
    1
    3      4
   21     40     16
  231    524    336    64
 3465   8784   7136  2304   256
65835 180756 170720 72320 14080 1024
"""
function Show(T, separator = ' ')
    AssertSeqArray(T)
    n = SeqSize(T)
    n == 0 && return
    AssertTriangular(n)
    i = k = 0
    while k < n - 1
        for j = 0:i
            print(T[k], separator)
            k += 1
        end
        i += 1
        println()
    end
end
doc"""
Display the row n of a lower triangular matrix (0 ≤ n).
"""
function Show(T, n::Int, separator = ' ')
    R = Row(T, n)
    for r in R print(r, separator) end
    println()
end
doc"""
Display element k of row n of a lower triangular matrix (0 ≤ k ≤ n).
"""
function Show(T, n::Int, k::Int)
    n < 0 && return
    AssertSeqArray(T)
    s = SeqSize(T)
    t = TriangularNumber(n)
    index = k + t
    (k > n || s < index) && error("This element is not in the matrix.")
    println(T[index])
end
doc"""
Reverse the rows of a triangular array in place.
"""
function RowReverse(T)
    AssertSeqArray(T)
    n = SeqSize(T)
    n == 0 && return T
    dim = AssertTriangular(n)
    lo = hi = 0
    step = 1
    while hi ≤ n
        l = lo; h = hi
        while l < h
            T[l], T[h] = T[h], T[l]
            l += 1; h -= 1
        end
        step += 1
        lo, hi = hi + 1, hi + step
    end
    T
end
doc"""
Convert a lower triangular array to a square matrix.
"""
function Δto□(T)
    AssertSeqArray(T)
    n = SeqSize(T)
    n == 0 && return T
    dim = AssertTriangular(n)
    A = fill(fmpz(0), dim, dim)
    k = 0
    for r in 1:dim
        for j = 1:r
            A[r, j] = T[k]
            k += 1
        end
    end
    A
end
doc"""
Convert a square matrix to a triangular array.
"""
function □toΔ(M)
    n = length(M)
    n == 0 && return M
    dim = AssertSquare(n)
    len = TriangularNumber(dim)
    T = SeqArray(len)
    k = 0
    for r in 1:dim
        for j = 1:r
            T[k] = fmpz(M[r, j])
            k += 1
        end
    end
    T
end
doc"""
Print the triangle T as a matrix.
"""
ShowAsMatrix(T) = println(Δto□(T))
doc"""
Return the row sums of a triangle, if "alternate=true" the alternating row sums.
"""
function RowSums(T, alternate = false)
    AssertSeqArray(T)
    n = SeqSize(T)
    n == 0 && return T
    dim = AssertTriangular(n)
    S = SeqArray(dim)
    lo = hi = step = 0
    while hi < n
        if alternate
            s = sum((-1)^k * T[lo + k] for k in 0:hi - lo)
        else
            s = sum(T[k] for k in lo:hi)
        end
        S[step] = s
        step += 1
        hi += 1
        lo, hi = hi, hi + step
    end
    S
end
doc"""
Return the name of a OEIS sequence given a similar named function as a string.
"""
function SeqName(fun)
    aname = string(fun)
    for X in ['L', 'T', 'G', 'B', 'Q']
        aname = replace(aname, X, 'A')
    end
    if !ismatch(r"^A[0-9]{6}$", aname)
        fullname = split(aname, ".")
        aname = String(fullname[end])
        if !ismatch(r"^A[0-9]{6}$", aname)
            warn("Not a valid A-name!")
            return
        end
    end
    aname
end
doc"""
Return the A-number of a OEIS sequence given a similar named function as an integer.
"""
function SeqNum(seq)
    aname = SeqName(seq)
    parse(Int, aname[2:end])
end
doc"""
Iverson brackets.
"""
ι(b) = b ? 1 : 0
doc"""
Inverse Iverson brackets.
"""
ιι(n) = n == 0 ? true : false
doc"""
Returns an integer which is the highest index in `b` for the value `a`.
Whenever `a` is not a member of `b` it returns -1.
julia> L = List(10, IsPrime)
IndexIn(13, L)
5
"""
function IndexIn(a, b::AbstractArray)
    bdict = Dict(zip(b, 0:length(linearindices(b))))
    get(bdict, fmpz(a), -1)
end
doc"""
Return the first element of the SeqArray A if A is not empty, 0 otherwise.
"""
Start(A) = A == [] ? "undef" : A[0]
doc"""
Return the element at the end of the list A if A is not empty, 0 otherwise.
"""
Last(A) = A == [] ? "undef" : A[SeqSize(A) - 1]  # A[end]
doc"""
Trick described by David Hilbert in a 1924 lecture "Über das Unendliche".
"""
HilbertHotel(guest, hotel) = prepend!(hotel, guest)
doc"""
Return the sqrt of ``n`` or throw an ArgumentError if ``n`` is not a square.
"""
function AssertSquare(n)
    dim = isqrt(n)
    n ≠ dim * dim && throw(ArgumentError("This is not a square!"))
    dim
end
doc"""
Enumerate the SeqArray A with linear index.
"""
function Enumerator(A)
    enumerate(IndexLinear(), A)
end
doc"""
Return a iterator listing the values of f for x in ``0≤x≤n``.
"""
function Iterator(n, f)
    (f(i) for i in 0:n)
end
doc"""
Return a iterator of length n reading from a channel.
"""
function Iterator(n, c::Channel)
    (take!(c) for i in 0:n - 1)
end
doc"""
Return a iterator of length n which has value 1 if isA(i) is true and otherwise 0.
"""
function Indicators(n, isA)
    (ι(isA(i)) for i in 0:n - 1)
end
doc"""
Return a list of length len which gives the numbers of integers ≤ n which
are isA.
julia> CountList(8, IsPrime)
[0, 0, 1, 2, 2, 3, 3, 4]
"""
CountList(len, isA) = Accumulate(Indicators(len, isA))
doc"""
Return the numbers of integers ≤ n which are isA.
julia> Count(8, IsPrime)
4
"""
function Count(n, isA)
    count(!iszero, Indicators(n + 1, isA))
end
doc"""
Return the Nth integer which is isA. (For N ≤ 0 return 0.)
julia> Nth(7, IsPrime)
17
"""
function Nth(N, isA::Function)
    N ≤ 0 && return 0
    n, c = Int(0), Int(0)
    while c < N
        i = isA(n)
        i && (c += 1)
        n += 1
    end
    n - 1
end
doc"""
Return the cumulative sum of an SeqArray.
"""
function Accumulate(A)
    R = SeqArray(SeqSize(A))
    i, acu = 0, 0
    for a in A
        acu += a
        R[i] = acu
        i += 1
    end
    R
end
doc"""
Return the smallest list of indicators of isA with sum(A) = count.
julia> IndicatorsFind(7, IsPrime)
[0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1]
"""
function IndicatorsFind(count, isA::Function)
    count ≤ 0 && return []
    n, c = Int(0), Int(0)
    A = Int[]
    while c < count
        i = isA(n)
        i && (c += 1)
        push!(A, ι(i))
        n += 1
    end
    A
end
doc"""
Return the first integer ``n ≥ 0`` such that isA(n) = true.
julia> First(IsPrime)
2
"""
function First(isA::Function)
    n = 0
    while !isA(n)
        n += 1
    end
    n
end
First(A::Array{Int}) = A == [] ? nothing : first(A)
doc"""
Return largest ``0 < k < n`` such that isA(k) = true or nothing if no such
``k`` exists.
julia> Previous(7, IsPrime)
5
"""
function Previous(n, isA::Function)
    n == nothing && return First(isA)
    while true
        n -= 1
        isA(n) && break
        n < 0 && return First(isA)
    end
    n
end
doc"""
Return least ``k > n ≥ 0`` such that isA(k) = true. NOTE: It is assumed that
such a ``k`` exists! (If not, the function will run forever.)
julia> Next(7, IsPrime)
11
"""
function Next(n, isA::Function)
    ((n ≤ 0) || (n == nothing)) && return First(isA)
    while true
        n += 1
        isA(n) && break
    end
    n
end
# +++ StirlingLahNumbers.jl +++
doc"""
Compute the generalized Stirling-Lah recurrence with weight function w.
"""
function StirlingLah(n::Int, k::Int, w::Function)
    @memoize function T(n::Int, k::Int)
        if n == k return fmpz(1) end
        if k < 0 || k > n return fmpz(0) end
        T(n - 1, k - 1) + w(n, k) * T(n - 1, k)
    end
    T(n, k)
end
doc"""
Return the Stirling set numbers (a.k.a. Stirling numbers of 2nd kind)
of order ``m``. Case ``m = 1`` is the classical case.
"""
StirlingSet(n::Int, k::Int, m = 1) = StirlingLah(n, k, (n, k) -> fmpz(k^m))
doc"""
Return the Stirling cycle numbers (a.k.a. unsigned Stirling numbers of 1st kind)
of order ``m``. Case ``m = 1`` is the classical case.
"""
StirlingCycle(n::Int, k::Int, m = 1) = StirlingLah(n, k, (n, k) -> fmpz((n - 1)^m))
doc"""
Return the Lah numbers of order ``m``. Case ``m=1`` is the classical case.
"""
Lah(n::Int, k::Int, m = 1) = StirlingLah(n, k, (n, k) -> k^m + fmpz((n - 1)^m))
doc"""
Compute the generalized Stirling-Lah square matrix of dimension dim and weight
function w.
"""
function StirlingLahMatrix(dim::Int, w::Function)
    M = SeqMatrix(dim)
    for n in 0:dim - 1
        M[n, n] = fmpz(1)
        for k in 1:n - 1
            M[n, k] = w(n - 1, k - 1) * M[n - 1, k] + M[n - 1, k - 1]
        end
    end
    M
end
doc"""
Compute the generalized Stirling-Lah triangle of dimension dim and weight
function w.
"""
function StirlingLahTriangle(dim::Int, w::Function)
    T = SeqTriangle(dim)
    T[0] = h = 1
    for s in 2:dim
        l = h; h += s
        T[l] = 0; T[h - 1] = 1
        for k in h - 2:-1:l + 1
            T[k] = w(s - 1, k - l) * T[k - s + 1] + T[k - s]
        end
    end
    T
end
doc"""
Return the first dim rows of the triangle of Stirling set numbers of order ``m``.
Case ``m=1`` is the classical case.
"""
StirlingSetTriangle(dim::Int, m = 1) = StirlingLahTriangle(dim, (n, k) -> fmpz(k^m))
doc"""
Return the first dim rows of the triangle of Stirling set numbers.
Counts partitions of an ``n``-set into ``k`` nonempty subsets.
"""
T048993(dim::Int) = StirlingSetTriangle(dim, 1)
doc"""
Return the first dim rows of the triangle of Stirling set numbers of order 2,
also known as central factorial numbers ``T(2n, 2k)``.
"""
T269945(dim::Int) = StirlingSetTriangle(dim, 2)
doc"""
Triangle of Stirling set numbers of order 3, also called 3rd central factorial
numbers.
"""
T269948(dim::Int) = StirlingSetTriangle(dim, 3)
doc"""
Return the first dim rows of the triangle of Stirling cycle numbers of order ``m``.
Case ``m=1`` is the classical case.
"""
StirlingCycleTriangle(dim::Int, m = 1) = StirlingLahTriangle(dim, (n, k) -> fmpz((n - 1)^m))
doc"""
Return the first dim rows of the triangle of Stirling cycle numbers.
Counts permutations of ``n`` objects with exactly ``k`` cycles.
"""
T132393(dim::Int) = StirlingCycleTriangle(dim, 1)
doc"""
Return the first dim rows of the triangle of Stirling cycle numbers of order 2,
also known as central factorial numbers ``|t(2n, 2k)|``.
"""
T269944(dim::Int) = StirlingCycleTriangle(dim, 2)
doc"""
Return the first dim rows of the triangle of Stirling cycle numbers of order 3.
"""
T269947(dim::Int) = StirlingCycleTriangle(dim, 3)
doc"""
Return the first dim rows of the triangle of Lah numbers of order ``m``.
Case ``m=1`` is the classical case.
"""
LahTriangle(dim::Int, m = 1) = StirlingLahTriangle(dim, (n, k) -> k^m + fmpz((n - 1)^m))
doc"""
Return the first dim rows of the triangle of the square of the Pascal triangle.
"""
T038207(dim::Int) = LahTriangle(dim, 0)
doc"""
Return the first dim rows of the triangle of unsigned Lah numbers.
Counts number of partitions of ``{1..n}`` into ``k`` ordered subset.
"""
T271703(dim::Int) = LahTriangle(dim, 1)
doc"""
Return the first dim rows of the triangle of Lah numbers of order 2.
"""
T268434(dim::Int) = LahTriangle(dim, 2)
doc"""
Return the first dim rows of the triangle of Lah numbers of order 3.
"""
T269946(dim::Int) = LahTriangle(dim, 3)
# +++ SwingingFactorial.jl +++
SwingOddpart = fmpz[1,1,1,3,3,15,5,35,35, 315, 63, 693, 231,
   3003, 429, 6435, 6435, 109395,12155,230945,46189,969969,
   88179,2028117, 676039,16900975,1300075,35102025,5014575,
   145422675,9694845,300540195,300540195]
doc"""
Return the odd part of the swinging factorial ``n≀``. Cf. A163590.
"""
function swing_oddpart(n)
    n < 33 && return SwingOddpart[n+1]
    sqrtn = isqrt(n)
    factors = Primes(div(n, 2) + 1, n)
    r = Primes(sqrtn + 1, div(n, 3))
    s = filter(x -> IsOdd(div(n, x)), r)
    append!(factors, s)
    for prime in Primes(3, sqrtn)
        p, q = 1, n
        while true
            q = div(q, prime)
            q == 0 && break
            IsOdd(q) && (p *= prime)
        end
        p > 1 && push!(factors, p)
    end
    ∏(factors)
end
doc"""
Return the swinging factorial (a.k.a. Swing numbers) ``n≀``. Cf. A056040.
"""
Swing(n) = swing_oddpart(n) << count_ones(div(n, 2))
doc"""
Return the odd part of the swinging factorial ``n≀``
"""
A163590(n) = swing_oddpart(n)
doc"""
Return the odd part of the central binomial coefficient.
"""
A001790(n) = swing_oddpart(2n)
doc"""
Return the odd part of the Apéry numbers.
"""
A001803(n) = swing_oddpart(2n + 1)
doc"""
Return the swinging factorial (a.k.a. Swing numbers) ``n≀``.
"""
A056040(n) = Swing(n)
doc"""
Return the central binomial coefficient.
"""
A000984(n) = Swing(2n)
doc"""
Return the central binomial coefficient.
"""
CentralBinomial(n) = Swing(2n)
doc"""
Return the n-th Apéry number, ``n \binom{2n}{n}``.
"""
Apéry(n) = n * Swing(2n)
doc"""
Return the n-th Apéry numbers, ``n \binom{2n}{n}``.
"""
A005430(n) = Apéry(n)
doc"""
Return ``(2n+1)! / n!^2``.
"""
A002457(n) = Swing(2n + 1)
doc"""
Return the squarefree kernel of the swinging factorial.
"""
A163641(n) = Radical(Swing(n))
doc"""
Return the squarefree kernel of the central binomial coefficient.
"""
A080397(n) = Radical(Swing(2n))
doc"""
Return the cumulative product of the swinging factorial.
"""
function L163085(len)
    L = SeqArray(len)
    L[0] = 1
    for n in 1:len-1
        L[n] = L[n-1] * Swing(n)
    end
    L
end
doc"""
Return lcm``({1,2,...,n}) / n≀``.
"""
function A180000(n::Int)
    N = [j for j in 1:n]
    N == [] ? 1 : div(fmpz(lcm(N)), Swing(n))
end
doc"""
Return the Louisa number of ``n``. Cf. A180000.
"""
LouisaNumber(n) = A180000(n)
doc"""
Return the n-th extended Catalan number. (Search for "Lost Catalan Numbers".)
"""
A057977(n) = div(Swing(n), div(n, 2) + 1)
doc"""
Return the n-th Catalan number.
"""
CatalanNumber(n) = div(Swing(2n), n + 1)
doc"""
Return the n-th Catalan number.
"""
A000108(n) = CatalanNumber(n)
doc"""
Return the squarefree kernel of the Catalan number.
"""
A281594(n) = Radical(CatalanNumber(n))
FactorialOddPart = fmpz[1, 1, 1, 3, 3, 15, 45, 315, 315, 2835, 14175, 155925,
    467775, 6081075, 42567525, 638512875, 638512875, 10854718875, 97692469875,
    1856156927625, 9280784638125, 194896477400625, 2143861251406875,
    49308808782358125, 147926426347074375, 3698160658676859375]
doc"""
Return the largest odd divisor of ``n!``. Cf. A049606.
"""
function factorial_oddpart(n)
    n < length(FactorialOddPart) && return ZZ(FactorialOddPart[n + 1])
    swing_oddpart(n)*(factorial_oddpart(div(n, 2))^2)
end
doc"""
Return the factorial ``n! = 1×2×...×n``. Alternatively you can call F!(n)
which uses the Nemo implementation. Cf. A000142.
"""
function Factorial(n)
    n < 0 && ArgumentError("Argument must be ≥ 0")
    sh = n - count_ones(n)
    factorial_oddpart(n) << sh
end
doc"""
Return the odd part of the factorial.
"""
A049606(n) = factorial_oddpart(n)
# +++ ZumkellerNumbers.jl +++
doc"""
Is ``n`` a Zumkeller number?
A Zumkeller number ``n`` is an integer whose divisors can be partitioned
into two disjoint sets whose sums are both ``σ(n)/2``.
"""
function IsZumkeller(n::Int)
    n == 0 && return false
    T = Divisors(n)
    s = sum(T)
    ((s % 2 ≠ 0) || (s < 2n)) && return false
    S = s >> 1 - n
    D = [d for d in T if d ≤ S]
    D == [] && return true
    for c in combinations(D)
        S == sum(c) && return true
    end
    return false 
end
doc"""
Return a list of length len of the first Zumkeller numbers.
"""
ZumkellerNumberList(len) = SeqArray(len, IsZumkeller)
doc"""
Return a list of length len of the first Zumkeller numbers.
"""
L083207(len) = SeqArray(len, IsZumkeller)
end