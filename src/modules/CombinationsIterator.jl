# This file was part of JuliaMath/Combinatorics.jl (see GitHub)
# and was modified here.
# License is MIT.

module CombinationsIterator

using IterTools
import Base: start, next, done, length, eltype

export combinations

immutable Combinations{T}
    a::T
    t::Int
end

start(c::Combinations) = [1:c.t;]

function next(c::Combinations, s)
    comb = [c.a[si] for si in s]
    if c.t == 0
        # special case to generate 1 result for t==0
        return (comb, [length(c.a) + 2])
    end
    s = copy(s)
    for i = length(s):-1:1
        s[i] += 1
        if s[i] > (length(c.a) - (length(s)-i))
            continue
        end
        for j = i+1:endof(s)
            s[j] = s[j - 1] + 1
        end
        break
    end
    (comb,s)
end

done(c::Combinations, s) = !isempty(s) && s[1] > length(c.a) - c.t + 1

length(c::Combinations) = binomial(length(c.a), c.t)

eltype{T}(::Type{Combinations{T}}) = Vector{eltype(T)}

"""
Generate all combinations of `n` elements from an indexable object. Because the
number of combinations can be very large, this function returns an iterator object.
Use `collect(combinations(array,n))` to get an array of all combinations.
"""
function combinations(a, t::Integer)
    if t < 0
        # generate 0 combinations for negative argument
        t = length(a) + 1
    end
    Combinations(a, t)
end

"""
generate combinations of all orders, chaining of order iterators is eager,
but sequence at each order is lazy
"""
combinations(a) = IterTools.chain([combinations(a, k) for k=1:length(a)]...)

end # module
