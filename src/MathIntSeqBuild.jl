# This file is part of OLMS (Open Library of Mathematical Sequences).
# Copyright Peter Luschny. License is MIT.

# Builds the modules MathIntSeq, runtests and perftests from the src modules.
#
# The source files are scanned and the source modules are joined together,
# not merely included. This architecture has three advantages:
# * Source and test modules can be placed in the same file.
# * A uniform layout of the source modules is enforced.
# * The build can be easily customized by filtering source files.

module MathIntSeqBuild
export build_all

gitdir = "https://github.com/OpenLibMathSeq/MathIntSeq/blob/master/src/modules/"
srcdir = realpath(joinpath(dirname(@__FILE__)))
pkgdir = dirname(srcdir)
moddir = joinpath(srcdir, "modules")
docdir = joinpath(pkgdir, "docs")
docsrcdir = joinpath(docdir, "src")
tstdir = joinpath(pkgdir, "test")

exclude = ["OLMS.jl", "SeqTests.jl"]

function header(f)
    println(f, "# This file is part of OLMS (Open Library of Mathematical Sequences).")
    println(f, "# Copyright Peter Luschny. License is MIT.")
    println(f)
    println(f, "# Version of: UTC ", Dates.format(now(), "yyyy-mm-dd HH:MM:SS"))
    println(f, "# ", Base.Random.uuid1())
    println(f)
    println(f, "# Do not edit this file, it is generated from the modules and will be overwritten!")
    println(f, "# Edit the modules in the modules directory and build this file with MathIntSeqBuild.jl!")
    println(f)
    println(f, "# Reporting a bug please give date, uuid and line number in this file, not of modules.")
    println(f)
end

function sortnames()

    index = open("_INDEX.jl", "r")
    sindex = open("S_INDEX.jl", "w")

    dict = Dict{Int64,Array{String}}()

    for l in eachline(index, chomp = false)

        i = 0; c = 2
        if ismatch(r"^[ABCLMGT][0-9]{6}[m!,],$", l) c = 1 end
        if ismatch(r"^[ABCLMGT][0-9]{6},$", l) c = 0 end
        if ismatch(r"^is[ABCLMGT][0-9]{6},$", l) i = 2; c = 0 end

        c == 2 && (print(sindex, l); continue)

        Anum = l[1:end - 2]
        N = parse(Anum[2 + i:end - c])

        if !haskey(dict, N)
            dict[N] = [Anum]
        else
            push!(dict[N], Anum)
        end
    end

    K = sort(collect(keys(dict)))
    for key in K[1:end - 1]
        for s in dict[key]
            println(sindex, s * ",")
        end
    end

    E = dict[K[end]]
    for s in E[1:end - 1]
        println(sindex, s * ",")
    end
    println(sindex, E[end])

    close(index)
    close(sindex)
end

# Nota bene: we make use of the convention that an MathIntSeq module
# is closed by "end # module" (and not merely by "end")!
# Also note that we do not support yet multiline comments (#= =#)
function build_seq(docdefs)

    tmp = open("_TEMP.jl", "w")
    exp = open("_EXPORT.jl", "w")

    seq_modules = filter!(r"\.jl$", readdir(moddir))
    for filename in seq_modules
        filename in exclude && continue
        path = joinpath(moddir, filename)
        mod = open(path, "r")
        println("# +++ ", filename)
        println(tmp, "# +++ ", filename, " +++")
        doc = save1 = save2 = false
        for l in eachline(mod, chomp = false)
            if save1 || save2
                save1 && println(tmp, "doc\"\"\"")
                docdefs && print(tmp, "* ", l)
                println(tmp, "\"\"\"")
                print(tmp, l)
                save1 = save2 = false
                continue
            end
            n = lstrip(l)
            n == "" && continue
            startswith(n, '#') && continue
            startswith(n, "using") && continue
            if startswith(n, "export")
            print(exp, n); continue; end
            startswith(n, "module") && continue
            startswith(n, "end # module") && break
            if startswith(n, "doc\"\"\"°\"\"\"")
            save1 = true; continue; end
            if startswith(n, "\"\"\"")
            save2 = true; continue; end
            print(tmp, l)
        end
        	    close(mod)
    end

    flush(exp)
    close(tmp)
    close(exp)
    sleep(0.1)
    exp = open("_EXPORT.jl", "r")
    sor = open("_INDEX.jl", "w")

    s = ""
    for l in eachline(exp, chomp = false)
        n = lstrip(l)
        if startswith(n, "export")
            n = n[7:end]
        end
        s *= n
    end
    R = replace(s, ',', ' ')
    T = sort(split(R))

    println(sor, "export ")
    for t in T[1:end]
        println(sor, t, ",")
    end

    close(sor)
    close(exp)
    sleep(0.01)

    sortnames()

    tmp = open("_TEMP.jl", "r")
    sor = open("S_INDEX.jl", "r")
    target = joinpath(srcdir, "MathIntSeq.jl")
    olm = open(target, "w")
    header(olm)
    ################################
    # Trouble with module Memoize
    # println(olm, "__precompile__(true)")
    ################################
    println(olm, "module MathIntSeq")
    println(olm, "using Memoize, Combinatorics, Requests, URIParser, Nemo, OffsetArrays")

    for l in eachline(sor, chomp = false) print(olm, l) end
    println("ROOTDIR name:")
    println(dirname(realpath(joinpath(dirname(@__FILE__)))))
    for l in eachline(tmp, chomp = false) print(olm, l) end
    print(olm, "end")

    close(sor)
    close(tmp)
    close(olm)
end

# Builds the file test/runtests.jl from the MathIntSeq modules.
# Nota bene: we make use of the convention that a MathIntSeq test module
# has three functions: test(), demo() and perf(), in this order.
function build_test()
    path = joinpath(tstdir, "runtests.jl")
    o = open(path, "w")

    header(o)
    println(o, "module runtests")
    println(o, "using Base.Test, Nemo, MathIntSeq")
    println(o, "oeis_notinstalled()")

    path = joinpath(moddir, "SeqTests.jl")
    i = open(path, "r")
    buff = Array{String,1}()
    for l in eachline(i, chomp = false)
        n = lstrip(l)
        startswith(n, '#') && continue
        startswith(n, "module") && continue
        startswith(n, "using") && continue
        startswith(n, "export") && continue
        push!(buff, n)
    end
    j = length(buff)
    while j > 0 && buff[j] == "" j -= 1 end

    for k in 1:j - 1
        print(o, buff[k])
    end
    close(i)

    seq_modules = filter!(r"\.jl$", readdir(moddir))
    for filename in seq_modules
        filename in exclude && continue
        path = joinpath(moddir, filename)
        i = open(path, "r")
        inside = false
        println(o, "# +++ ", filename, " +++")

        buff = Array{String,1}()
        for l in eachline(i, chomp = false)
            n = lstrip(l)
            startswith(n, '#') && continue
            b = startswith(n, "function test()")
            if b inside = true; continue end

            if inside
                c = startswith(n, "function") && n[10] ≠ 't'
                if c break end
                push!(buff, n)
            end
        end

        j = length(buff)
        while j > 0 && buff[j] == "" j -= 1 end

        for k in 1:j - 1
            print(o, buff[k])
        end
        	    close(i)
    end
    print(o, "end # module")
    close(o)
end

# Builds the file test/perftests.jl from the MathIntSeq modules.
function build_perf()
    path = joinpath(tstdir, "perftests.jl")
    o = open(path, "w")

    header(o)
    println(o, "module perftests")
    println(o, "using Nemo, MathIntSeq")

    println(o, "versioninfo()") # "versioninfo(true)"
    println(o, "start = now()")

    seq_modules = filter!(r"\.jl$", readdir(moddir))
    for filename in seq_modules
        filename in exclude && continue
        path = joinpath(moddir, filename)
        i = open(path, "r")
        inside = false
        println(o, "# +++ ", filename, " +++")

        buff = Array{String,1}()
        s = ""
        for l in eachline(i, chomp = false)
            n = lstrip(l)
            b = startswith(n, "function perf()")
            if b inside = true; continue end
            if inside
                c = startswith(n, "function main")
                if c break end
                startswith(n, '#') && continue
                if startswith(n, "@time")
                    s = chomp(n[7:end]) * "\")\n"
                    push!(buff, "println(\"\\nTEST: ", s)
                end
                push!(buff, n)
            end
        end

        j = length(buff)
        while j > 0 && buff[j] == "" j -= 1 end

        for k in 1:j - 1
            print(o, buff[k])
        end
        	    close(i)
    end

    println(o, "stop = now()")
    println(o, "tdiff = Int(stop - start) / 1000")
    println(o, "println(\"\\nJulia version: \" * string(VERSION) )")
    println(o, "println(start)")
    println(o, "println(\"Total test time: \", tdiff, \" seconds\")")
    println(o, "end # module")
    close(o)
end

# Builds the file index.md in docs/src.
function make_index()
    path = joinpath(docsrcdir, "index.md")
    ind = open(path, "w")
    tind = open("S_INDEX.jl", "r")
    println(ind, "```@docs")

    first = true
    for l in eachline(tind, chomp = false)
        first && (first = false; continue)
        l = replace(l, r"[,]", "")
        print(ind, l)
    end

    println(ind, "```")
    close(ind)
    close(tind)
end

# Builds the file modules.md in docs/src.
function get_modules()

    path = joinpath(docsrcdir, "modules.md")
    mod = open(path, "w")
    println(mod, "# Modules")
    seq_modules = filter!(r"\.jl$", readdir(moddir))
    for filename in seq_modules
        filename in exclude && continue
        name = split(filename, ".")
        println(mod, "[", name[1], "](", gitdir, filename, ")")
    end
    close(mod)
end

function build_all(docdefs = false)
    build_seq(docdefs)
    build_test()
    build_perf()
    make_index()
    get_modules()
    rm("_TEMP.jl")
    rm("_EXPORT.jl")
    rm("_INDEX.jl")
    rm("S_INDEX.jl")
end

#build_all()

end # module